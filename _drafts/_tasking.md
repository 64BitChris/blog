---
layout: post
title: "How Micro Is Your Tasking?"
date: 2017-11-20
place: Moscow, Russia
tags: management
description: |
  ...
keywords:
  - microtasking
  - micromanagement
  - xdsd micro tasking
  - micro management
  - management tasking
image: /images/2017/11/...
jb_picture:
  caption:
---

"What are you doing now?"&mdash;when you hear this question
from your boss, be aware: you're dealing with a
[micromanager]({% pst 2015/sep/2015-09-22-micromanagement %}).
Keeping us busy is the key objective of these creatures and this
is what makes them so annoying. To the contrary, effective managers
make sure we are _productive_, meaning that our results satisfy
their expectations. They are not interested to know what we are
doing to deliver them. They manage the project, instead of managing us.
And the best way to make the project manageable is to break its
scope to small and manageable pieces.

<!--more-->

{% jb_picture_body %}

Imagine, you want to redesign your appartment and have a few thousand
dollars for this job. You hire a group of people and give them all your
money. They ask you to come back in two months, when everything will
be ready. You say "OK" and wait for two months. I'm sure you already know
what I'm getting at&mdash;this project most probably will be a failure, to
some extend. In the worst case you won't see these guys ever, they will just
steal your money. In the best case, they will do something that will
look nice.

## Why do we micromanage?

What do you do in order to increase chances to get the best case scenario?
That's right, you micromanage them: you visit them every day, you ask them
the famous "What are you doing now?" question, you push them when they are
getting lazy, you control, you dominate, you annoy, you
"stay on top," you play the guilt card when they miss or forget
anything, you [punish]({% pst 2016/jan/2016-01-05-how-to-punish-employees %})
them every way you can.

You don't do that because you're evil. You just know that otherwise they
will redesign your appartment forever, will forget things, will miss
something, will make mistakes, will spend more money than they are
supposed to, will choose wrong fabrics, will purchase the furniture
you don't like, and will do many other things you're well aware of if you
ever dealt with interior designers and house builders.

The more aggressive you are, the higher the chances to win.

And it's not because you are evil. You're not evil, you're stupid
(not you personally, my dear and respected reader, but you get the point).

The problem is that the project is not manageable. That's why you will
have to resort to the last possible measure&mdash;micromanagement. Why the
project is not manageable? Because its scope is not broken down into
pieces. It contains a single job: "Redesign the Apartment."

One of the key factors of managability is the famous 0/100 rule, which
requires any task to be either "in progress" or "complete." There could be
nothing in the middle. When such a rule is in place, the task can be
delegated to its performer and they can become responsible for its completion,
they can be trusted.

We can't "trust" our single trust to the performer, simply because it's too
big to be trusted. If they fail, the cost of failure will be too high. We have
to take a _micro-scope_ and go _into_ the task to manage it from the inside,
annoying its performers, who we are supposed to trust. The micromanagement
we will do is _inevitable_, because the scope is not broken down.

Scope decomposition was invented mostly in order to solve this very problem:
to make the project more manageable. We need small tasks in the scope in order
to be able to delegate them and never go inside in order to check what's going on
there, who is doing what, why, and where.

The smaller the tasks we can break the scope into, the better.

## What obstacles did we have?

In our projects we break project scope to tasks of 30 minutes each.
This may sound too extreme for you, but it works for us. We call them micro-tasks.
We started to practice microtasking about six years ago. We experimented
with different task sizes, from 10 hours to 15 minutes, but eventually
came down to 30 minutes.

If you decide to go for microtasking, you will most likely have same or similar
obstacles. Here is a short list of them and my advice, which
may help if one day you decide to break a "Develop a Mobile App" task
to 2,500 micro tasks:

  * **Vagueness**.
    Definition of done, exit criteria, requirements, expectations&mdash;there
    are many names, which are all about our inability to define
    what exactly we expect programmers to do. Software development
    by definition anticipates a lot of unknowns, creativity, experiments,
    and risks. Programmers will tell you that they can't guarantee anything
    in most cases, and can't really give any valid promises.
    We solve that by
    [PDD]({% pst 2009/mar/2009-03-04-pdd %}).

  * **Distraction**.
    Programmers are used to many different things at the same time:
    writing code, helping others, watching YouTube, scrolling Facebook,
    swearing at Reddit, and reading my blog. Initially most of them
    won't like the idea of having explicit and small tasks in front of them,
    simply because they put a structure on their work time, making it
    much more visible to the management. They will tell you that they
    have many other things to do aside from your bloody tasks.
    We solved that by
    [paying by result]({% pst 2014/apr/2014-04-17-how-xdsd-is-different %}) and
    [prohibition of chitchats]({% pst 2014/oct/2014-10-07-stop-chatting-start-coding %}).

  * **Laziness**.
    Just like that apartment designers, programmers also love to get paid
    and do nothing. Who doesn't, right? They will tell you that their
    work is more complicated than you think, that they need much more time,
    that they need to investigate the problem first, that reading
    documentation also takes a lot of time, etc. They are simply spoiled
    by the traditional macro-tasking where they are paid by the month and nobody
    really controls their results. They are used to be lazy.
    We solved that by
    [paying by result]({% pst 2014/apr/2014-04-17-how-xdsd-is-different %})
    and the lazy ones simply quit.

  * **Responsibility**.
    Microtasking will make individual results visible. When tasks are large
    people tend to work with them in groups and it's unclear namely who is responsible
    for failures and successes. Smaller tasks make emphasize mistakes
    and make people "pay" for them. Not necessarily with cash (like we do),
    but definitely somehow else. Most programmers will find this concept
    very new and disturbing&mdash;they almost never paid for their own
    mistakes before and never had their own tasks. Their responsibility was
    always spread accross the group.
    We solved that by
    [monetary rewards and punishments]({% pst 2014/sep/2014-09-24-why-monetary-awards-dont-work %}),
    which made them very movitated and failure tolerant.

  * **Resentment**.
    This is one of the most popular and the most annoying problem: they
    will tell you that they are not monkeys. They will actually combine
    all problems listed above and say that the right way to solve them
    is to give programmers freedom and let them do their job, since they
    are smart enough and don't need any management on top of them. And they
    will mostly be saying it honestly, with no intent to manipulate. The thing
    is that they are used to macro-tasking and believe that this is the
    only and the right way.
    I'm trying to solve this by writing this very blog post.

There could be something else, but this is a more or less exhaustive list
of problems we were faced to.

## Where it doesn't work?

Obviously, any approach has its pros and cons. Microtasking seems to be
the most effective management paradigm for us. However, it's not applicable
everywhere, according to our experience. There are territories where
we failed to apply it.

  * **Prototyping**.
    Every project or a new big feature starts with a prototype, which
    requires one-two persons sitting next to each other, thinking, and
    experimenting. We tried to break this piece of work to smaller
    parts, but failed. It seems that this process has to be done as a single
    solid work package.

  * **UI/UX**.
    We were mostly working with server-side Java/Ruby/C++ projects for the last
    few years and didn't have many opportunities to apply microtasking to the
    UI/UX jobs. However, where we tried nothing really worked: graphic
    designers weren't able to decompose their tasks to smaller parts.

  * **Customers**.
    We tried to decompose the task of eliciting requirements from our
    clients and failed a few times. Maybe our clients were stupid
    (I doubt that), maybe requirements were too complex, or maybe
    our system analysts were not professional enough. The bottom line
    is that we realized that such a task must be done as a solid piece of
    work, without any decomposition.

  * **Fire-fighting**.
    When the speed of delivery was the most important concern, micro-tasking
    didn't work for us. The overhead for tasks dispatching and specifying
    was taking too much time. When something is really urgent, we had
    to do the traditional macro-tasking and just "make it work." Then
    we were getting back to micro-tasking.

Everything else, including programming, unit testing, manual testing,
performance/load testing, integration testing, deployment, code review,
documentation, and even training can and must be managed via micro tasks.

## What benefits did we get?

The most important benefit of microtasking is that the project becomes
more manageable, as was mentioned above. Here is a more detailed break
down of it.

  * **Money works**.
    When tasks are very small, we can use good old dollar bills
    to motivate programmers. We can throw away literally
    [all other]({% pst 2015/mar/2015-03-02-team-morale-myths-and-reality %})
    instruments.

  * **We pay less**.
    We seriously cut our expensenses, while hourly rates of our programmers
    are
    [higher]({% pst 2014/oct/2014-10-29-how-much-do-you-cost %})
    than many other projects can afford. I did a more or less
    [detailed analysis]({% pst 2014/apr/2014-04-11-cost-of-loc %})
    a few years ago, which demonstrated that our project
    were 30 (!) times more cost efficient than a traditional one.

  * **Movitation is high**.
    Despite the

  * **Turnover is not painful**.
    Despite the

clearer goal

isolation of dependencies

better parallelism, higher speed in parallel development

personal responsibility

possible to pay per result

necessity to define scope makes it cleaner

easier to apply quality standards

success and failure are easier to observe and reward or punish

delegate and trust is possible

no algorithms, only objectives and exit criteria

DoD is easier

## Are we monkeys or not?

