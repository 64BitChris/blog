<!DOCTYPE html>
<html âš¡ lang="en">
  <head>
    <meta charset="utf-8">
    <title></title>
    <link rel="canonical" href="http://www.yegor256.com" />
    <meta name="viewport" content="width=device-width,minimum-scale=1,initial-scale=1">
    <style amp-boilerplate>body{-webkit-animation:-amp-start 8s steps(1,end) 0s 1 normal both;-moz-animation:-amp-start 8s steps(1,end) 0s 1 normal both;-ms-animation:-amp-start 8s steps(1,end) 0s 1 normal both;animation:-amp-start 8s steps(1,end) 0s 1 normal both}@-webkit-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-moz-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-ms-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-o-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}</style><noscript><style amp-boilerplate>body{-webkit-animation:none;-moz-animation:none;-ms-animation:none;animation:none}</style></noscript>
    <script async src="https://cdn.ampproject.org/v0.js"></script>
  </head>
  <body>
    <h1></h1>
    <p><a href="https://en.wikipedia.org/wiki/Debugging">Debugging</a>
is &quot;a process of running a program/method interactively,
breaking execution flow after each statement and showing...&quot; In a nutshell, it is
a very useful technique ... for a bad programmer. Or an old programmer
who is still writing procedural code in C. Object-oriented programmers
never debug their code &mdash; they write unit tests. My point here
is that unit testing is a technique that completely replaces debugging.
If debugging is required, the <strong>design is bad</strong>.</p>

<!--more-->



<p>Let&#39;s say I&#39;m a <a href="/2014/05/05/oop-alternative-to-utility-classes.html">bad</a>
imperative procedural programmer, and this is my Java code:</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nc">FileUtils</span> <span class="o">{</span>
  <span class="kd">public</span> <span class="kd">static</span> <span class="n">Iterable</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="nf">readWords</span><span class="o">(</span><span class="n">File</span> <span class="n">f</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">String</span> <span class="n">text</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">String</span><span class="o">(</span>
      <span class="n">Files</span><span class="o">.</span><span class="na">readAllBytes</span><span class="o">(</span><span class="n">Paths</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">f</span><span class="o">)),</span>
      <span class="s">&quot;UTF-8&quot;</span>
    <span class="o">);</span>
    <span class="n">Set</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">words</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashSet</span><span class="o">&lt;&gt;();</span>
    <span class="k">for</span> <span class="o">(</span><span class="n">String</span> <span class="n">word</span> <span class="o">:</span> <span class="n">text</span><span class="o">.</span><span class="na">split</span><span class="o">(</span><span class="s">&quot; &quot;</span><span class="o">))</span> <span class="o">{</span>
      <span class="n">words</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">word</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">words</span><span class="o">;</span>
  <span class="o">}</span>
<span class="o">}</span></code></pre></figure>

<p>This static <a href="/2014/05/05/oop-alternative-to-utility-classes.html">utility</a>
method reads file content and then
finds all the unique words in it. Pretty simple. However, if
it doesn&#39;t work, what do we do? Let&#39;s say this is the file:</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">We know what we are,
but know not what we may be.</code></pre></figure>

<p>From it, we get this list of words:</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">&quot;We&quot;
&quot;know&quot;
&quot;what&quot;
&quot;we&quot;
&quot;are,\n&quot;
&quot;but&quot;
&quot;not&quot;
&quot;may&quot;
&quot;be\n&quot;</code></pre></figure>

<p>Now that doesn&#39;t look right to me ... so what is the next step? Either the file
reading doesn&#39;t work correctly or the split is broken. Let&#39;s <strong>debug</strong>, right?
Let&#39;s give it a file through an input and go step by step, tracing and watching
the variables. We&#39;ll find the bug and fix it. But when a similar
problem shows up, we&#39;ll have to debug again! And that&#39;s what unit testing
is supposed to <strong>prevent</strong>.</p>

<p>We&#39;re supposed to create a unit test once, in which the problem is reproduced.
Then we fix the problem and make sure the test passes. That&#39;s how we save
our investments in problem solving. We won&#39;t fix it again, because it won&#39;t
happen again. Our <strong>test</strong> will prevent it from happening.</p>

<p>However, all this will work only if it&#39;s easy to create a unit test. If it&#39;s
difficult, I&#39;ll be too lazy to do it. I will just debug and fix the problem.
In this particular example, creating a test is a rather expensive procedure.
What I mean is the complexity of the unit test will be rather high. We have to
create a temporary file, fill it with data, run the method, and check the results.
To find out what&#39;s going on and where the bug is, I&#39;ll have to create a number
of tests. To avoid code duplication, I&#39;ll also have to create some supplementary
utilities to help me create that temporary file and fill it with data.
That&#39;s a lot of work. Well, maybe not &quot;a lot&quot;, but way more than a few minutes
of debugging.</p>

<p>Thus, if you perceive debugging to be faster and easier, think about the quality
of your code. I bet it has a lot of opportunities for refactoring, just like
the code from the example above. Here is how I would modify it. First of all,
I would turn it into a class, because utility static methods are a
<a href="/2014/05/05/oop-alternative-to-utility-classes.html">bad practice</a>:</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nc">Words</span> <span class="kd">implements</span> <span class="n">Iterable</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="o">{</span>
  <span class="kd">private</span> <span class="kd">final</span> <span class="n">File</span> <span class="n">file</span><span class="o">;</span>
  <span class="n">Words</span><span class="o">(</span><span class="n">File</span> <span class="n">src</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">this</span><span class="o">.</span><span class="na">file</span> <span class="o">=</span> <span class="n">src</span><span class="o">;</span>
  <span class="o">}</span>
  <span class="nd">@Override</span>
  <span class="kd">public</span> <span class="n">Iterator</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="nf">iterator</span><span class="o">()</span> <span class="o">{</span>
    <span class="n">String</span> <span class="n">text</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">String</span><span class="o">(</span>
      <span class="n">Files</span><span class="o">.</span><span class="na">readAllBytes</span><span class="o">(</span><span class="n">Paths</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">file</span><span class="o">)),</span>
      <span class="s">&quot;UTF-8&quot;</span>
    <span class="o">);</span>
    <span class="n">Set</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">words</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashSet</span><span class="o">&lt;&gt;();</span>
    <span class="k">for</span> <span class="o">(</span><span class="n">String</span> <span class="n">word</span> <span class="o">:</span> <span class="n">text</span><span class="o">.</span><span class="na">split</span><span class="o">(</span><span class="s">&quot; &quot;</span><span class="o">))</span> <span class="o">{</span>
      <span class="n">words</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">word</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">words</span><span class="o">.</span><span class="na">iterator</span><span class="o">();</span>
  <span class="o">}</span>
<span class="o">}</span></code></pre></figure>

<p>It looks better already, but the complexity is still there. Next, I would
break it down into smaller classes:</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nc">Text</span> <span class="o">{</span>
  <span class="kd">private</span> <span class="kd">final</span> <span class="n">File</span> <span class="n">file</span><span class="o">;</span>
  <span class="n">Text</span><span class="o">(</span><span class="n">File</span> <span class="n">src</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">this</span><span class="o">.</span><span class="na">file</span> <span class="o">=</span> <span class="n">src</span><span class="o">;</span>
  <span class="o">}</span>
  <span class="nd">@Override</span>
  <span class="kd">public</span> <span class="n">String</span> <span class="nf">toString</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nf">String</span><span class="o">(</span>
      <span class="n">Files</span><span class="o">.</span><span class="na">readAllBytes</span><span class="o">(</span><span class="n">Paths</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">file</span><span class="o">)),</span>
      <span class="s">&quot;UTF-8&quot;</span>
    <span class="o">);</span>
  <span class="o">}</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">Words</span> <span class="kd">implements</span> <span class="n">Iterable</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="o">{</span>
  <span class="kd">private</span> <span class="kd">final</span> <span class="n">String</span> <span class="n">text</span><span class="o">;</span>
  <span class="n">Words</span><span class="o">(</span><span class="n">String</span> <span class="n">txt</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">this</span><span class="o">.</span><span class="na">text</span> <span class="o">=</span> <span class="n">txt</span><span class="o">;</span>
  <span class="o">}</span>
  <span class="nd">@Override</span>
  <span class="kd">public</span> <span class="n">Iterator</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="nf">iterator</span><span class="o">()</span> <span class="o">{</span>
    <span class="n">Set</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">words</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashSet</span><span class="o">&lt;&gt;();</span>
    <span class="k">for</span> <span class="o">(</span><span class="n">String</span> <span class="n">word</span> <span class="o">:</span> <span class="k">this</span><span class="o">.</span><span class="na">text</span><span class="o">.</span><span class="na">split</span><span class="o">(</span><span class="s">&quot; &quot;</span><span class="o">))</span> <span class="o">{</span>
      <span class="n">words</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">word</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">words</span><span class="o">.</span><span class="na">iterator</span><span class="o">();</span>
  <span class="o">}</span>
<span class="o">}</span></code></pre></figure>

<p>What do you think now? Writing a test for the <code>Words</code> class is a pretty
trivial task:</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kn">import</span> <span class="nn">org.junit.Test</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">static</span> <span class="n">org</span><span class="o">.</span><span class="na">hamcrest</span><span class="o">.</span><span class="na">MatcherAssert</span><span class="o">.*;</span>
<span class="kn">import</span> <span class="nn">static</span> <span class="n">org</span><span class="o">.</span><span class="na">hamcrest</span><span class="o">.</span><span class="na">Matchers</span><span class="o">.*;</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">WordsTest</span> <span class="o">{</span>
  <span class="nd">@Test</span>
  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">parsesSimpleText</span><span class="o">()</span> <span class="o">{</span>
    <span class="n">assertThat</span><span class="o">(</span>
      <span class="k">new</span> <span class="nf">Words</span><span class="o">(</span><span class="s">&quot;How are you?&quot;</span><span class="o">),</span>
      <span class="n">hasItems</span><span class="o">(</span><span class="s">&quot;How&quot;</span><span class="o">,</span> <span class="s">&quot;are&quot;</span><span class="o">,</span> <span class="s">&quot;you&quot;</span><span class="o">)</span>
    <span class="o">);</span>
  <span class="o">}</span>
<span class="o">}</span></code></pre></figure>

<p>How much time did that take? Less than a minute. We don&#39;t need to create
a temporary file and load it with data, because class <code>Words</code> doesn&#39;t do
anything with files. It just parses the incoming string and finds the unique
words in it. Now it&#39;s easy to fix, since the test is small and we can
easily create more tests; for example:</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kn">import</span> <span class="nn">org.junit.Test</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">static</span> <span class="n">org</span><span class="o">.</span><span class="na">hamcrest</span><span class="o">.</span><span class="na">MatcherAssert</span><span class="o">.*;</span>
<span class="kn">import</span> <span class="nn">static</span> <span class="n">org</span><span class="o">.</span><span class="na">hamcrest</span><span class="o">.</span><span class="na">Matchers</span><span class="o">.*;</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">WordsTest</span> <span class="o">{</span>
  <span class="nd">@Test</span>
  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">parsesSimpleText</span><span class="o">()</span> <span class="o">{</span>
    <span class="n">assertThat</span><span class="o">(</span>
      <span class="k">new</span> <span class="nf">Words</span><span class="o">(</span><span class="s">&quot;How are you?&quot;</span><span class="o">),</span>
      <span class="n">hasItems</span><span class="o">(</span><span class="s">&quot;How&quot;</span><span class="o">,</span> <span class="s">&quot;are&quot;</span><span class="o">,</span> <span class="s">&quot;you&quot;</span><span class="o">)</span>
    <span class="o">);</span>
  <span class="o">}</span>
  <span class="nd">@Test</span>
  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">parsesMultipleLines</span><span class="o">()</span> <span class="o">{</span>
    <span class="n">assertThat</span><span class="o">(</span>
      <span class="k">new</span> <span class="nf">Words</span><span class="o">(</span><span class="s">&quot;first line\nsecond line\n&quot;</span><span class="o">),</span>
      <span class="n">hasItems</span><span class="o">(</span><span class="s">&quot;first&quot;</span><span class="o">,</span> <span class="s">&quot;second&quot;</span><span class="o">,</span> <span class="s">&quot;line&quot;</span><span class="o">)</span>
    <span class="o">);</span>
  <span class="o">}</span>
<span class="o">}</span></code></pre></figure>

<p>My point is that debugging is necessary when the amount of time
to write a unit test is significantly more than the time it takes to click
those Trace-In/Trace-Out buttons. And it&#39;s logical. We all are lazy and
want fast and easy solutions. But debugging burns time and wastes
energy. It helps us find problems but doesn&#39;t help prevent
them from reappearing.</p>

<p>Debugging is needed when our code is
<a href="/2015/02/20/utility-classes-vs-functional-programming.html">procedural</a>
and algorithmic &mdash; when the code is all
about <strong>how</strong> the goal should be achieved instead of <strong>what</strong> the goal is.
See the examples above again. The first static method is all about
how we read the file, parse it, and find words. It&#39;s even named <code>readWords()</code> (a <strong>verb</strong>).
To the contrary, the second example is about what will be achieved. It&#39;s either
the <code>Text</code> of the file or <code>Words</code> of the text (both are <strong>nouns</strong>).</p>

<p>I believe there is no place for debugging in clean object-oriented
programming. Only unit testing!</p>

  </body>
</html>
