<!DOCTYPE html>
<html âš¡ lang="en">
  <head>
    <meta charset="utf-8">
    <title></title>
    <link rel="canonical" href="http://www.yegor256.com" />
    <meta name="viewport" content="width=device-width,minimum-scale=1,initial-scale=1">
    <style amp-boilerplate>body{-webkit-animation:-amp-start 8s steps(1,end) 0s 1 normal both;-moz-animation:-amp-start 8s steps(1,end) 0s 1 normal both;-ms-animation:-amp-start 8s steps(1,end) 0s 1 normal both;animation:-amp-start 8s steps(1,end) 0s 1 normal both}@-webkit-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-moz-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-ms-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-o-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}</style><noscript><style amp-boilerplate>body{-webkit-animation:none;-moz-animation:none;-ms-animation:none;animation:none}</style></noscript>
    <script async src="https://cdn.ampproject.org/v0.js"></script>
  </head>
  <body>
    <h1></h1>
    <p><a href="https://en.wikipedia.org/wiki/Java_annotation">Annotations</a>
were introduced in Java 5, and we all got excited. Such a great
instrument to make code shorter! No more Hibernate/Spring XML configuration
files! Just annotations, right there in the code where we need them. No more
<a href="https://en.wikipedia.org/wiki/Marker_interface_pattern">marker interfaces</a>,
just a <a href="https://docs.oracle.com/javase/7/docs/api/java/lang/annotation/Retention.html">runtime-retained</a>
<a href="http://stackoverflow.com/questions/4296910/">reflection-discoverable</a> annotation!
I was excited too. Moreover, I&#39;ve made a few open source libraries which
use annotations heavily. Take <a href="https://github.com/jcabi/jcabi-aspects">jcabi-aspects</a>,
for example. However, I&#39;m not excited any more. Moreover, I believe that
annotations are a big mistake in Java design.</p>

<!--more-->

<p>Long story short, there is one big problem with annotations &mdash;
they encourage us to implement
<a href="/2014/11/20/seven-virtues-of-good-object.html">object</a>
functionality <strong>outside</strong> of an object,
which is against the very principle of
<a href="https://en.wikipedia.org/wiki/Encapsulation_%28computer_programming%29">encapsulation</a>.
The object is not solid any more, since its behavior is not defined entirely by its own
methods &mdash; some of its functionality stays elsewhere. Why is it bad? Let&#39;s
see in a few examples.</p>

<h2 id="inject"><code>@Inject</code></h2>

<p>Say we annotate a property with <code>@Inject</code>:</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kn">import</span> <span class="nn">javax.inject.Inject</span><span class="o">;</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Books</span> <span class="o">{</span>
  <span class="nd">@Inject</span>
  <span class="kd">private</span> <span class="kd">final</span> <span class="n">DB</span> <span class="n">db</span><span class="o">;</span>
  <span class="c1">// some methods here, which use this.db</span>
<span class="o">}</span></code></pre></figure>

<p>Then we have an injector that knows what to inject:</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">Injector</span> <span class="n">injector</span> <span class="o">=</span> <span class="n">Guice</span><span class="o">.</span><span class="na">createInjector</span><span class="o">(</span>
  <span class="k">new</span> <span class="nf">AbstractModule</span><span class="o">()</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">configure</span><span class="o">()</span> <span class="o">{</span>
      <span class="k">this</span><span class="o">.</span><span class="na">bind</span><span class="o">(</span><span class="n">DB</span><span class="o">.</span><span class="na">class</span><span class="o">).</span><span class="na">toInstance</span><span class="o">(</span>
        <span class="k">new</span> <span class="nf">Postgres</span><span class="o">(</span><span class="s">&quot;jdbc:postgresql:5740/main&quot;</span><span class="o">)</span>
      <span class="o">);</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">);</span></code></pre></figure>

<p>Now we&#39;re making an instance of class <code>Books</code> via the container:</p>



<p>The class <code>Books</code> has no idea how and who will inject an instance
of class <code>DB</code> into it. This will happen behind the scenes and outside
of its control. The injection will do it. It may look convenient,
but this attitude causes a lot of damage to the entire code base. The
control is lost (not inverted, but lost!). The object is not in charge
any more. It can&#39;t be responsible for what&#39;s happening to it.</p>

<p>Instead, here is how this should be done:</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nc">Books</span> <span class="o">{</span>
  <span class="kd">private</span> <span class="kd">final</span> <span class="n">DB</span> <span class="n">db</span><span class="o">;</span>
  <span class="n">Books</span><span class="o">(</span><span class="kd">final</span> <span class="n">DB</span> <span class="n">base</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">this</span><span class="o">.</span><span class="na">db</span> <span class="o">=</span> <span class="n">base</span><span class="o">;</span>
  <span class="o">}</span>
  <span class="c1">// some methods here, which use this.db</span>
<span class="o">}</span></code></pre></figure>

<p>This article explains why Dependency Injection containers are
a wrong idea in the first place:
<a href="/2014/10/03/di-containers-are-evil.html">Dependency Injection Containers are Code Polluters</a>.
Annotations basically provoke us to make the containers and use them.
We move functionality outside of our objects and put it into
containers, or somewhere else. That&#39;s because we don&#39;t want to duplicate the
same code over and over again, right? That&#39;s correct, duplication is
bad, but tearing an object apart is even worse. Way worse. The same is
true about ORM (JPA/Hibernate), where annotations are being actively used.
Check this post, it explains what is wrong about ORM:
<a href="/2014/12/01/orm-offensive-anti-pattern.html">ORM Is an Offensive Anti-Pattern</a>.
Annotations by themselves are not the key motivator, but they help us
and encourage us by tearing objects apart and keeping parts in different
places. They are containers, sessions, managers, controllers, etc.</p>

<h2 id="xmlelement"><code>@XmlElement</code></h2>

<p>This is how JAXB
<a href="/2015/03/26/jaxb-vs-xembly.html">works</a>, when you want to convert your
<a href="https://en.wikipedia.org/wiki/Plain_Old_Java_Object">POJO</a> to XML. First,
you attach the <code>@XmlElement</code> annotation to the getter:</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kn">import</span> <span class="nn">javax.xml.bind.annotation.XmlElement</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">javax.xml.bind.annotation.XmlRootElement</span><span class="o">;</span>
<span class="nd">@XmlRootElement</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Book</span> <span class="o">{</span>
  <span class="kd">private</span> <span class="kd">final</span> <span class="n">String</span> <span class="n">title</span><span class="o">;</span>
  <span class="kd">public</span> <span class="nf">Book</span><span class="o">(</span><span class="kd">final</span> <span class="n">String</span> <span class="n">title</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">this</span><span class="o">.</span><span class="na">title</span> <span class="o">=</span> <span class="n">title</span><span class="o">;</span>
  <span class="o">}</span>
  <span class="nd">@XmlElement</span>
  <span class="kd">public</span> <span class="n">String</span> <span class="nf">getTitle</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="k">this</span><span class="o">.</span><span class="na">title</span><span class="o">;</span>
  <span class="o">}</span>
<span class="o">}</span></code></pre></figure>

<p>Then, you create a marshaller and ask it to convert an instance of class
<code>Book</code> into XML:</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">final</span> <span class="n">Book</span> <span class="n">book</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">Book</span><span class="o">(</span><span class="s">&quot;0132350882&quot;</span><span class="o">,</span> <span class="s">&quot;Clean Code&quot;</span><span class="o">);</span>
<span class="kd">final</span> <span class="n">JAXBContext</span> <span class="n">context</span> <span class="o">=</span> <span class="n">JAXBContext</span><span class="o">.</span><span class="na">newInstance</span><span class="o">(</span><span class="n">Book</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
<span class="kd">final</span> <span class="n">Marshaller</span> <span class="n">marshaller</span> <span class="o">=</span> <span class="n">jaxbContext</span><span class="o">.</span><span class="na">createMarshaller</span><span class="o">();</span>
<span class="n">marshaller</span><span class="o">.</span><span class="na">marshal</span><span class="o">(</span><span class="n">book</span><span class="o">,</span> <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">);</span></code></pre></figure>

<p>Who is creating the XML? Not the <code>book</code>. Someone else, outside of the
class <code>Book</code>. This is very wrong. Instead, this is how this should have
been done. First, the class that has no idea about XML:</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nc">DefaultBook</span> <span class="kd">implements</span> <span class="n">Book</span> <span class="o">{</span>
  <span class="kd">private</span> <span class="kd">final</span> <span class="n">String</span> <span class="n">title</span><span class="o">;</span>
  <span class="n">DefaultBook</span><span class="o">(</span><span class="kd">final</span> <span class="n">String</span> <span class="n">title</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">this</span><span class="o">.</span><span class="na">title</span> <span class="o">=</span> <span class="n">title</span><span class="o">;</span>
  <span class="o">}</span>
  <span class="nd">@Override</span>
  <span class="kd">public</span> <span class="n">String</span> <span class="nf">getTitle</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="k">this</span><span class="o">.</span><span class="na">title</span><span class="o">;</span>
  <span class="o">}</span>
<span class="o">}</span></code></pre></figure>

<p>Then, the
<a href="/2015/02/26/composable-decorators.html">decorator</a>
that prints it to the XML:</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nc">XmlBook</span> <span class="kd">implements</span> <span class="n">Book</span><span class="o">{</span>
  <span class="kd">private</span> <span class="kd">final</span> <span class="n">Book</span> <span class="n">origin</span><span class="o">;</span>
  <span class="n">XmlBook</span><span class="o">(</span><span class="kd">final</span> <span class="n">Book</span> <span class="n">book</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">this</span><span class="o">.</span><span class="na">origin</span> <span class="o">=</span> <span class="n">book</span><span class="o">;</span>
  <span class="o">}</span>
  <span class="nd">@Override</span>
  <span class="kd">public</span> <span class="n">String</span> <span class="nf">getTitle</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="k">this</span><span class="o">.</span><span class="na">origin</span><span class="o">.</span><span class="na">getTitle</span><span class="o">();</span>
  <span class="o">}</span>
  <span class="kd">public</span> <span class="n">String</span> <span class="nf">toXML</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">String</span><span class="o">.</span><span class="na">format</span><span class="o">(</span>
      <span class="s">&quot;&lt;book&gt;&lt;title&gt;%s&lt;/title&gt;&lt;/book&gt;&quot;</span><span class="o">,</span>
      <span class="k">this</span><span class="o">.</span><span class="na">getTitle</span><span class="o">()</span>
    <span class="o">);</span>
  <span class="o">}</span>
<span class="o">}</span></code></pre></figure>

<p>Now, in order to <a href="/2016/04/05/printers-instead-of-getters.html">print</a>
the book in XML we do the following:</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">String</span> <span class="n">xml</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">XmlBook</span><span class="o">(</span>
  <span class="k">new</span> <span class="nf">DefaultBook</span><span class="o">(</span><span class="s">&quot;Elegant Objects&quot;</span><span class="o">)</span>
<span class="o">).</span><span class="na">toXML</span><span class="o">();</span></code></pre></figure>

<p>The XML printing functionality is inside <code>XmlBook</code>. If you don&#39;t like the
decorator idea, you can move the <code>toXML()</code> method to the <code>DefaultBook</code> class. It&#39;s
not important. What is important is that the functionality always stays
where it belongs &mdash; inside the object. Only the object knows how
to
<a href="/2016/04/05/printers-instead-of-getters.html">print itself</a>
to the XML. Nobody else!</p>

<h2 id="retryonfailure"><code>@RetryOnFailure</code></h2>

<p>Here is an example
(from <a href="/2014/08/15/retry-java-method-on-exception.html">my own library</a>):</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kn">import</span> <span class="nn">com.jcabi.aspects.RetryOnFailure</span><span class="o">;</span>
<span class="kd">class</span> <span class="nc">Foo</span> <span class="o">{</span>
  <span class="nd">@RetryOnFailure</span>
  <span class="kd">public</span> <span class="n">String</span> <span class="nf">load</span><span class="o">(</span><span class="n">URL</span> <span class="n">url</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">url</span><span class="o">.</span><span class="na">openConnection</span><span class="o">().</span><span class="na">getContent</span><span class="o">();</span>
  <span class="o">}</span>
<span class="o">}</span></code></pre></figure>

<p>After compilation, we run a so called
<a href="/2014/06/01/aop-aspectj-java-method-logging.html">AOP weaver</a>
that technically turns our code into something like this:</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nc">Foo</span> <span class="o">{</span>
  <span class="kd">public</span> <span class="n">String</span> <span class="nf">load</span><span class="o">(</span><span class="n">URL</span> <span class="n">url</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">while</span> <span class="o">(</span><span class="kc">true</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">try</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">_Foo</span><span class="o">.</span><span class="na">load</span><span class="o">(</span><span class="n">url</span><span class="o">);</span>
      <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">Exception</span> <span class="n">ex</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// ignore it</span>
      <span class="o">}</span>
    <span class="o">}</span>
  <span class="o">}</span>
  <span class="kd">class</span> <span class="nc">_Foo</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="n">String</span> <span class="nf">load</span><span class="o">(</span><span class="n">URL</span> <span class="n">url</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">return</span> <span class="n">url</span><span class="o">.</span><span class="na">openConnection</span><span class="o">().</span><span class="na">getContent</span><span class="o">();</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span></code></pre></figure>

<p>I simplified the actual algorithm of retrying a method call on failure, but I&#39;m
sure you get the idea. <a href="http://www.aspectj.org">AspectJ</a>,
the <a href="http://en.wikipedia.org/wiki/Aspect-oriented_programming">AOP</a>
engine, uses
<a href="http://aspects.jcabi.com/annotation-retryonfailure.html"><code>@RetryOnFailure</code></a>
annotation as a signal, informing us that the class
has to be wrapped into another one. This is happening behind the scenes. We don&#39;t
see that supplementary class, which implements the retrying algorithm.
But the bytecode produced by the AspectJ weaver contains a modified
version of class <code>Foo</code>.</p>

<p>That is exactly what is wrong with this approach &mdash; we don&#39;t see
and don&#39;t control the instantiation of that supplementary object. Object
composition, which is the most important process in object design, is
hidden somewhere behind the scenes. You may say that we don&#39;t need
to see it since it&#39;s supplementary. I disagree. We must see how
our objects are composed. We may not care about how they work, but we
must see the entire composition process.</p>

<p>A much better design would look like this (instead of annotations):</p>



<p>And then, the implementation of <code>FooThatRetries</code>:</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nc">FooThatRetries</span> <span class="kd">implements</span> <span class="n">Foo</span> <span class="o">{</span>
  <span class="kd">private</span> <span class="kd">final</span> <span class="n">Foo</span> <span class="n">origin</span><span class="o">;</span>
  <span class="n">FooThatRetries</span><span class="o">(</span><span class="n">Foo</span> <span class="n">foo</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">this</span><span class="o">.</span><span class="na">origin</span> <span class="o">=</span> <span class="n">foo</span><span class="o">;</span>
  <span class="o">}</span>
  <span class="kd">public</span> <span class="n">String</span> <span class="nf">load</span><span class="o">(</span><span class="n">URL</span> <span class="n">url</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nf">Retry</span><span class="o">().</span><span class="na">eval</span><span class="o">(</span>
      <span class="k">new</span> <span class="n">Retry</span><span class="o">.</span><span class="na">Algorithm</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;()</span> <span class="o">{</span>
        <span class="nd">@Override</span>
        <span class="kd">public</span> <span class="n">String</span> <span class="nf">eval</span><span class="o">()</span> <span class="o">{</span>
          <span class="k">return</span> <span class="n">FooThatRetries</span><span class="o">.</span><span class="na">this</span><span class="o">.</span><span class="na">load</span><span class="o">(</span><span class="n">url</span><span class="o">);</span>
        <span class="o">}</span>
      <span class="o">}</span>
    <span class="o">);</span>
  <span class="o">}</span>
<span class="o">}</span></code></pre></figure>

<p>And now, the implementation of <code>Retry</code>:</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nc">Retry</span> <span class="o">{</span>
  <span class="kd">public</span> <span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">T</span> <span class="nf">eval</span><span class="o">(</span><span class="n">Retry</span><span class="o">.</span><span class="na">Algorithm</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">algo</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">while</span> <span class="o">(</span><span class="kc">true</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">try</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">algo</span><span class="o">.</span><span class="na">eval</span><span class="o">();</span>
      <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">Exception</span> <span class="n">ex</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// ignore it</span>
      <span class="o">}</span>
    <span class="o">}</span>
  <span class="o">}</span>
  <span class="kd">interface</span> <span class="nc">Algorithm</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="n">T</span> <span class="nf">eval</span><span class="o">();</span>
  <span class="o">}</span>
<span class="o">}</span></code></pre></figure>

<p>Is the code longer? Yes. Is it cleaner? A lot more. I regret that I
didn&#39;t understand it two years ago, when I started to work with
<a href="https://github.com/jcabi/jcabi-aspects">jcabi-aspects</a>.</p>

<hr/>

<p>The bottom line is that annotations are bad. Don&#39;t use them. What should be used
instead? Object <a href="/2015/02/26/composable-decorators.html">composition</a>.</p>

<p>What could be worse than annotations? <a href="/2016/04/19/object-must-not-be-configurable.html">Configurations</a>.
For example, XML configurations. Spring XML configuration mechanisms is a perfect
example of terrible design. I&#39;ve said it many times before. Let
me repeat it again &mdash; Spring Framework is one of the worst
software products in the Java world. If you can stay away from it, you will
do yourself a big favor.</p>

<p>There should not be any &quot;configurations&quot; in OOP. We can&#39;t configure our
objects if they are real objects. We can only instantiate them. And the
best method of instantiation is operator <code>new</code>. This operator is the key
instrument for an OOP developer. Taking it away from us and giving us
&quot;configuration mechanisms&quot; is an unforgivable
<a href="/2015/11/24/imprisonment-for-irresponsible-coding.html">crime</a>.</p>

  </body>
</html>
