<!DOCTYPE html>
<html âš¡ lang="en">
  <head>
    <meta charset="utf-8">
    <title>Why InputStream Design Is Wrong</title>
    <link rel="canonical" href="http://www.yegor256.com/2016/04/26/why-inputstream-design-is-wrong.html" />
    <meta name="viewport" content="width=device-width,minimum-scale=1,initial-scale=1">
    <script type='application/ld+json'>
      {
        "@context": "http://schema.org",
        "@type": "BlogPosting",
        "mainEntityOfPage":{
          "@type": "WebPage",
          "@id": "http://www.yegor256.com/2016/04/26/why-inputstream-design-is-wrong.html"
        },
        "headline": "Why InputStream Design Is Wrong",
        "image": {
          "@type": "ImageObject",
          "url": "http://img.teamed.io/face-1400x1400.jpg",
          "height": 1400,
          "width": 1400
        },
        "datePublished": "2016-04-26",
        "dateModified": "2016-04-26",
        "author": {
          "@type": "Person",
          "name": "Yegor Bugayenko"
        },
        "publisher": {
          "@type": "Organization",
          "name": "yegor256.com",
          "logo": {
            "@type": "ImageObject",
            "url": "http://img.teamed.io/face-512x512.jpg",
            "width": 512,
            "height": 512
          }
        },
        "description": "Class InputStream in Java has three methods read(),
this is what I think is very wrong. Not only in
this class, but in general in OOP.
",
        "keywords": ["why InputStream is a class", "InputStream", "InputStream java", "method overloading", "method overloading java"]
      }
    </script>
    <style amp-boilerplate>body{-webkit-animation:-amp-start 8s steps(1,end) 0s 1 normal both;-moz-animation:-amp-start 8s steps(1,end) 0s 1 normal both;-ms-animation:-amp-start 8s steps(1,end) 0s 1 normal both;animation:-amp-start 8s steps(1,end) 0s 1 normal both}@-webkit-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-moz-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-ms-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-o-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}</style><noscript><style amp-boilerplate>body{-webkit-animation:none;-moz-animation:none;-ms-animation:none;animation:none}</style></noscript>
    <style amp-custom="amp-custom">
      body { padding: 2em; }
      article { width: 600px; max-width: 100%; margin-left: auto; margin-right: auto; }
    </style>
    <script async src="https://cdn.ampproject.org/v0.js"></script>
  </head>
  <body>
    <article>
      <h1>Why InputStream Design Is Wrong</h1>
      <p>It&#39;s not just about <code>InputSteam</code>, this class is a good
example of a bad design. I&#39;m talking about three overloaded
methods <code>read()</code>. I&#39;ve mentioned this problem in Section 2.9
of <a href="/elegant-objects.html">Elegant Objects</a>. In a few words,
I strongly believe that interfaces must be &quot;functionality poor.&quot;
<code>InputStream</code> should have been an interface in the first place
and it should have had a single method <code>read(byte[])</code>. Then if
its authors wanted to give us extra functionality, they should have
created supplementary &quot;smart&quot; classes.</p>

<!--more-->

A Serious Man (2009) by Coen Brothers

<p>This is how it looks now:</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">InputStream</span> <span class="o">{</span>
  <span class="kt">int</span> <span class="nf">read</span><span class="o">();</span>
  <span class="kt">int</span> <span class="nf">read</span><span class="o">(</span><span class="kt">byte</span><span class="o">[]</span> <span class="n">buffer</span><span class="o">,</span> <span class="kt">int</span> <span class="n">offset</span><span class="o">,</span> <span class="kt">int</span> <span class="n">length</span><span class="o">);</span>
  <span class="kt">int</span> <span class="nf">read</span><span class="o">(</span><span class="kt">byte</span><span class="o">[]</span> <span class="n">buffer</span><span class="o">);</span>
<span class="o">}</span></code></pre></figure>

<p>What&#39;s wrong? It&#39;s very convenient to have the ability to read
a single byte, an array of bytes or even an array of bytes
with a direct positioning into a specific place in the buffer!</p>

<p>However, we are still lacking a few methods: for reading the bytes and
immediately saving into a file, converting to a text with a selected
encoding, sending them by email and posting on Twitter. It would be
great to have the features too, right in the poor <code>InputStream</code>.
I hope the Oracle Java team is working on them now.</p>

<p>In the mean time, let&#39;s see what exactly is wrong with what these
bright engineers designed for us already. Or maybe let me show
how I would design <code>InputStream</code> and we&#39;ll compare:</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">interface</span> <span class="nc">InputStream</span> <span class="o">{</span>
  <span class="kt">int</span> <span class="nf">read</span><span class="o">(</span><span class="kt">byte</span><span class="o">[]</span> <span class="n">buffer</span><span class="o">,</span> <span class="kt">int</span> <span class="n">offset</span><span class="o">,</span> <span class="kt">int</span> <span class="n">length</span><span class="o">);</span>
<span class="o">}</span></code></pre></figure>

<p>This is my design. The <code>InputStream</code> is responsible for reading
bytes from the stream. There is one single method for this
feature. Is it convenient for everybody? Does it read and post
on Twitter? Not yet. Do we need that functionality? Of course we do,
but it doesn&#39;t mean that we will add it to the interface. Instead,
we will create supplementary &quot;smart&quot; class:</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">interface</span> <span class="nc">InputStream</span> <span class="o">{</span>
  <span class="kt">int</span> <span class="nf">read</span><span class="o">(</span><span class="kt">byte</span><span class="o">[]</span> <span class="n">buffer</span><span class="o">,</span> <span class="kt">int</span> <span class="n">offset</span><span class="o">,</span> <span class="kt">int</span> <span class="n">length</span><span class="o">);</span>
  <span class="kd">class</span> <span class="nc">Smart</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="n">InputStream</span> <span class="n">origin</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">Smart</span><span class="o">(</span><span class="n">InputStream</span> <span class="n">stream</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">this</span><span class="o">.</span><span class="na">origin</span> <span class="o">=</span> <span class="n">stream</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">read</span><span class="o">()</span> <span class="o">{</span>
      <span class="kd">final</span> <span class="kt">byte</span><span class="o">[]</span> <span class="n">buffer</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">byte</span><span class="o">[</span><span class="mi">1</span><span class="o">];</span>
      <span class="kd">final</span> <span class="kt">int</span> <span class="n">read</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">origin</span><span class="o">.</span><span class="na">read</span><span class="o">(</span><span class="n">buffer</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">);</span>
      <span class="kd">final</span> <span class="kt">int</span> <span class="n">result</span><span class="o">;</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">read</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">result</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
      <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">buffer</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
      <span class="o">}</span>
      <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span></code></pre></figure>

<p>Now, we want to read a single byte from the stream. Here is how:</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">final</span> <span class="n">InputStream</span> <span class="n">input</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">FileInputStream</span><span class="o">(</span><span class="s">&quot;/tmp/a.txt&quot;</span><span class="o">);</span>
<span class="kd">final</span> <span class="kt">byte</span> <span class="n">b</span> <span class="o">=</span> <span class="k">new</span> <span class="n">InputStream</span><span class="o">.</span><span class="na">Smart</span><span class="o">(</span><span class="n">input</span><span class="o">).</span><span class="na">read</span><span class="o">();</span></code></pre></figure>

<p>The functionality of reading a single byte is outside of <code>InputStream</code>,
because this is not its business. The stream doesn&#39;t need to know
how to manage the data after it is read. All the stream
is <strong>responsible</strong> for is reading, not parsing or manipulating afterwards.</p>

<p>Interfaces must be small.</p>

<p>Obviously, method overloading in interfaces is a code smell. An interface
with more than <strong>three methods</strong> is a good candidate for refactoring. If methods
overload each other &mdash; it&#39;s serious trouble.</p>

<p>Interfaces must be small!</p>

<p>You may say that the creators of <code>InputStream</code> cared about performance, that&#39;s
why allowed us to implement <code>read()</code> in three different forms. Then I have
to ask again, why not create a method for reading and immediately post it
on Twitter? That would be fantastically fast. Isn&#39;t it what we all want?
A fast software which nobody has any desire to read or maintain.</p>

    </article>
  </body>
</html>
