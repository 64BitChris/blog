<!DOCTYPE html>
<html âš¡ lang="en">
  <head>
    <meta charset="utf-8">
    <title>Defensive Programming via Validating Decorators</title>
    <!-- <link rel="canonical" href="http://www.yegor256.com/_posts/2016/jan/2016-01-26-defensive-programming" /> -->
    <meta name="viewport" content="width=device-width,minimum-scale=1,initial-scale=1">
    <script type='application/ld+json'>
      {
        "@context": "http://schema.org",
        "@type": "BlogPosting",
        "mainEntityOfPage":{
          "@type": "WebPage",
          "@id": "_posts/2016/jan/2016-01-26-defensive-programming.md"
        },
        "headline": "Defensive Programming via Validating Decorators",
        "image": {
          "@type": "ImageObject",
          "url": "http://img.teamed.io/face-1400x1400.jpg",
          "height": 1400,
          "width": 1400
        },
        "datePublished": "2016-01-26",
        "dateModified": "2016-01-26",
        "author": {
          "@type": "Person",
          "name": "Yegor Bugayenko"
        },
        "publisher": {
          "@type": "Organization",
          "name": "yegor256.com",
          "logo": {
            "@type": "ImageObject",
            "url": "http://img.teamed.io/face-1400x1400.jpg",
            "width": 1400,
            "height": 1400
          }
        },
        "description": "Defensive programming is a good idea, but the way
it gets implemented is, in most cases, very wrong;
here is what I'm suggesting instead.
",
        "keywords": ["defensive programming", "validators in oop", "check for null", "validate method arguments", "startup failure stories"]
      }
    </script>
    <style amp-boilerplate>body{-webkit-animation:-amp-start 8s steps(1,end) 0s 1 normal both;-moz-animation:-amp-start 8s steps(1,end) 0s 1 normal both;-ms-animation:-amp-start 8s steps(1,end) 0s 1 normal both;animation:-amp-start 8s steps(1,end) 0s 1 normal both}@-webkit-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-moz-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-ms-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-o-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}</style><noscript><style amp-boilerplate>body{-webkit-animation:none;-moz-animation:none;-ms-animation:none;animation:none}</style></noscript>
    <script async src="https://cdn.ampproject.org/v0.js"></script>
  </head>
  <body>
    <h1>Defensive Programming via Validating Decorators</h1>
    <p>Do you check the input parameters of your methods for validity?
I don&#39;t. I used to, but not anymore.
I just let my methods crash with a null pointer and other exceptions
when parameters are not valid.
This may sound illogical, but only in the beginning.
I&#39;m suggesting you use <strong>validating decorators</strong> instead.</p>

<!--more-->



<p>Let&#39;s take a look at this rather typical Java example:</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nc">Report</span> <span class="o">{</span>
  <span class="kt">void</span> <span class="nf">export</span><span class="o">(</span><span class="n">File</span> <span class="n">file</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">file</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">throw</span> <span class="k">new</span> <span class="nf">IllegalArgumentException</span><span class="o">(</span>
        <span class="s">&quot;File is NULL; can&#39;t export.&quot;</span>
      <span class="o">);</span>
    <span class="o">}</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">file</span><span class="o">.</span><span class="na">exists</span><span class="o">())</span> <span class="o">{</span>
      <span class="k">throw</span> <span class="k">new</span> <span class="nf">IllegalArgumentException</span><span class="o">(</span>
        <span class="s">&quot;File already exists.&quot;</span>
      <span class="o">);</span>
    <span class="o">}</span>
    <span class="c1">// Export the report to the file</span>
  <span class="o">}</span>
<span class="o">}</span></code></pre></figure>

<p>Pretty <a href="https://en.wikipedia.org/wiki/Defensive_programming">defensive</a>, right?
If we remove these validations, the code
will be much shorter, but it will crash with rather confusing messages
if <code>NULL</code> is provided by the client. Moreover, if the file already exists,
our <code>Report</code> will silently overwrite it. Pretty dangerous, right?</p>

<p>Yes, we must protect ourselves, and we must be defensive.</p>

<p>But not this way, not by bloating the class with validations that
have nothing to do with its core functionality. Instead, we should
use decorators to do the validation. Here is how. First,
there must be an interface <code>Report</code>:</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">interface</span> <span class="nc">Report</span> <span class="o">{</span>
  <span class="kt">void</span> <span class="nf">export</span><span class="o">(</span><span class="n">File</span> <span class="n">file</span><span class="o">);</span>
<span class="o">}</span></code></pre></figure>

<p>Then, a class that implements the core functionality:</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nc">DefaultReport</span> <span class="kd">implements</span> <span class="n">Report</span> <span class="o">{</span>
  <span class="nd">@Override</span>
  <span class="kt">void</span> <span class="nf">export</span><span class="o">(</span><span class="n">File</span> <span class="n">file</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// Export the report to the file</span>
  <span class="o">}</span>
<span class="o">}</span></code></pre></figure>

<p>And, finally, a number of decorators that will protect us:</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nc">NoWriteOverReport</span> <span class="kd">implements</span> <span class="n">Report</span> <span class="o">{</span>
  <span class="kd">private</span> <span class="kd">final</span> <span class="n">Report</span> <span class="n">origin</span><span class="o">;</span>
  <span class="n">NoWriteOverReport</span><span class="o">(</span><span class="n">Report</span> <span class="n">rep</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">this</span><span class="o">.</span><span class="na">origin</span> <span class="o">=</span> <span class="n">rep</span><span class="o">;</span>
  <span class="o">}</span>
  <span class="nd">@Override</span>
  <span class="kt">void</span> <span class="nf">export</span><span class="o">(</span><span class="n">File</span> <span class="n">file</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">file</span><span class="o">.</span><span class="na">exists</span><span class="o">())</span> <span class="o">{</span>
      <span class="k">throw</span> <span class="k">new</span> <span class="nf">IllegalArgumentException</span><span class="o">(</span>
        <span class="s">&quot;File already exists.&quot;</span>
      <span class="o">);</span>
    <span class="o">}</span>
    <span class="k">this</span><span class="o">.</span><span class="na">origin</span><span class="o">.</span><span class="na">export</span><span class="o">(</span><span class="n">file</span><span class="o">);</span>
  <span class="o">}</span>
<span class="o">}</span></code></pre></figure>

<p>Now, the client has the flexibility of composing a complex object
from decorators that perform their specific tasks. The core object
will do the reporting, while the decorators will validate parameters:</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">Report</span> <span class="n">report</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">NoNullReport</span><span class="o">(</span>
  <span class="k">new</span> <span class="nf">NoWriteOverReport</span><span class="o">(</span>
    <span class="k">new</span> <span class="nf">DefaultReport</span><span class="o">()</span>
  <span class="o">)</span>
<span class="o">);</span>
<span class="n">report</span><span class="o">.</span><span class="na">export</span><span class="o">(</span><span class="n">file</span><span class="o">);</span></code></pre></figure>

<p>What do we achieve with this approach?
First and foremost: smaller objects.
And smaller objects always mean higher <strong>maintainability</strong>.
Our <code>DefaultReport</code> class will always remain small, no matter
how many validations we may invent in the future. The
more things we need to validate, the more validating decorators
we will create. All of them will be small and cohesive. And we&#39;ll
be able to put them together in different variations.</p>

<p>Besides that, this approach makes our code much more
<strong>reusable</strong>, as classes perform very few operations
and don&#39;t defend themselves by default. While being defensive
is an important feature, we&#39;ll use validating decorators. But
this will not always be the case. Sometimes validation is just
too expensive in terms of time and memory, and we may want to work
directly with objects that don&#39;t defend themselves.</p>

<p>I also decided not to use the Java Validation API anymore for the
same reason. Its annotations make classes much more verbose
and less cohesive. I&#39;m using validating decorators instead.</p>

  </body>
</html>
