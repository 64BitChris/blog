<!DOCTYPE html> <html xmlns="http://www.w3.org/1999/xhtml" lang="en-US" xml:lang="en-US" itemscope="" itemtype="http://schema.org/WebSite"> <head> <meta charset="utf-8"/> <meta name="description" content="&lt;p&gt;Do we need checked exceptions at all? The &lt;a href=&quot;http://stackoverflow.com/questions/6115896/java-checked-vs-unchecked-exception-explanation&quot;&gt;debate&lt;/a&gt; is over, isn’t it? Not for me. While most object-oriented languages don’t have them, and most programmers think checked exceptions are a Java mistake, I believe in the opposite—unchecked exceptions are the &lt;strong&gt;mistake&lt;/strong&gt;. Moreover, I believe multiple exception types are a bad idea too.&lt;/p&gt; &lt;!--more--&gt; &lt;figure class=&quot;jb_picture&quot;&gt;&lt;img itemprop=&quot;image&quot; alt=&quot;True Romance (1993) by Tony Scott&quot; src=&quot;/images/2015/07/true-romance.jpg&quot; longdesc=&quot;#443dfa82&quot; /&gt;&lt;figcaption id=&quot;443dfa82&quot;&gt;True Romance (1993) by Tony Scott&lt;/figcaption&gt;&lt;/figure&gt; &lt;p&gt;Let me first explain how I understand exceptions in object-oriented programming. Then I’ll compare my understanding with a “traditional” approach, and we’ll discuss the differences. So, my understanding first.&lt;/p&gt; &lt;p&gt;Say there is a method that saves some binary data to a file:&lt;/p&gt; &lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;save&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;File&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;file&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;byte&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;throws&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Exception&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// save data to the file&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt; &lt;p&gt;When everything goes right, the method just saves the data and returns control. When something is wrong, it &lt;a href=&quot;/2015/12/01/rethrow-exceptions.html&quot;&gt;throws&lt;/a&gt; &lt;code&gt;Exception&lt;/code&gt; and we have to do something about it:&lt;/p&gt; &lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;save&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;file&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Exception&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ex&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;Sorry, we can&amp;#39;t save right now.&amp;quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt; &lt;p&gt;When a method says it &lt;code&gt;throws&lt;/code&gt; an exception, I understand that the method is not &lt;strong&gt;safe&lt;/strong&gt;. It may fail sometimes, and it’s my responsibility to either 1) handle this failure or 2) declare myself as &lt;strong&gt;unsafe&lt;/strong&gt; too.&lt;/p&gt; &lt;p&gt;I know each method is designed with a &lt;a href=&quot;https://en.wikipedia.org/wiki/Single_responsibility_principle&quot;&gt;single responsibility principle&lt;/a&gt; in mind. This is a guarantee to me that if method &lt;code&gt;save()&lt;/code&gt; fails, it means the entire saving operation can’t be completed. If I need to know what the cause of this failure was, I will &lt;a href=&quot;https://en.wikipedia.org/wiki/Exception_chaining&quot;&gt;un-chain&lt;/a&gt; the exception—traverse the stack of chained exceptions and stack traces encapsulated in &lt;code&gt;ex&lt;/code&gt;.&lt;/p&gt; &lt;p&gt;I never use exceptions for flow control, which means I &lt;strong&gt;never recover&lt;/strong&gt; situations where exceptions are thrown. When an exception occurs, I let it float up to the highest level of the application. Sometimes I &lt;a href=&quot;/2015/12/01/rethrow-exceptions.html&quot;&gt;rethrow&lt;/a&gt; it in order to add more semantic information to the chain. That’s why it doesn’t matter to me what the cause of the exception thrown by &lt;code&gt;save()&lt;/code&gt; was. I just know the method failed. That’s enough for me. Always.&lt;/p&gt; &lt;p&gt;For the same reason, I don’t need to differentiate between different exception types. I just don’t need that type of hierarchy. &lt;code&gt;Exception&lt;/code&gt; is enough for me. Again, that’s because I don’t use exceptions for flow control.&lt;/p&gt; &lt;p&gt;That’s how I understand exceptions.&lt;/p&gt; &lt;p&gt;According to this paradigm, I would say we must:&lt;/p&gt; &lt;ul&gt; &lt;li&gt;Always use checked exceptions.&lt;/li&gt; &lt;li&gt;Never throw/use unchecked exceptions.&lt;/li&gt; &lt;li&gt;Use only &lt;code&gt;Exception&lt;/code&gt;, without any sub-types.&lt;/li&gt; &lt;li&gt;Always declare one exception type in the &lt;code&gt;throws&lt;/code&gt; block.&lt;/li&gt; &lt;li&gt;Never catch without rethrowing; read &lt;a href=&quot;/2015/07/09/catch-if-cant-otherwise.html&quot;&gt;more about that here&lt;/a&gt;.&lt;/li&gt; &lt;/ul&gt; &lt;p&gt;This paradigm diverges from many other articles I’ve found on this subject. Let’s compare and discuss.&lt;/p&gt; &lt;h2 id=&quot;runtime-vs-api-exceptions&quot;&gt;Runtime vs. API Exceptions&lt;/h2&gt; &lt;p&gt;&lt;a href=&quot;http://docs.oracle.com/javase/tutorial/essential/exceptions/runtime.html&quot;&gt;Oracle says&lt;/a&gt; some exceptions should be part of API (checked ones) while some are runtime exceptions and should not be part of it (unchecked). They will be documented in JavaDoc but not in the method signature.&lt;/p&gt; &lt;p&gt;I don’t understand the logic here, and I’m sure Java designers don’t understand it either. How and why are some exceptions important while others are not? Why do some of them deserve a proper API position in the &lt;code&gt;throws&lt;/code&gt; block of the method signature while others don’t? What is the criteria?&lt;/p&gt; &lt;p&gt;I have an answer here, though. By introducing checked and unchecked exceptions, Java developers tried to solve the problem of methods that are too complex and messy. When a method is too big and does too many things at the same time (violates the single responsibility principle), it’s definitely better to let us keep some exceptions “hidden” (a.k.a. unchecked). But it’s not a real solution. It is only a temporary patch that does all of us more harm than good—methods keep growing in size and complexity.&lt;/p&gt; &lt;p&gt;Unchecked exceptions are a mistake in Java design, not &lt;a href=&quot;/2015/10/20/interrupted-exception.html&quot;&gt;checked&lt;/a&gt; ones.&lt;/p&gt; &lt;p&gt;Hiding the fact that a method may fail at some point is a mistake. That’s exactly what unchecked exceptions do.&lt;/p&gt; &lt;p&gt;Instead, we should make this fact visible. When a method does too many things, there will be too many points of failure, and the author of the method will realize that something is wrong—a method should not throw exceptions in so many situations. This will lead to refactoring. The existence of unchecked exceptions leads to a mess. By the way, checked exceptions don’t exist at all in Ruby, C#, Python, PHP, etc. This means that creators of these languages understand &lt;a href=&quot;/2016/08/15/what-is-wrong-object-oriented-programming.html&quot;&gt;OOP&lt;/a&gt; even less than Java authors.&lt;/p&gt; &lt;h2 id=&quot;checked-exceptions-are-too-noisy&quot;&gt;Checked Exceptions Are Too Noisy&lt;/h2&gt; &lt;p&gt;Another common argument against checked exceptions is that they make our code more verbose. We have to put &lt;code&gt;try/catch&lt;/code&gt; everywhere instead of staying focused on the main logic. Bozhidar Bozhanov even &lt;a href=&quot;http://techblog.bozho.net/checked-and-unchecked-exceptions-in-java/&quot;&gt;suggests&lt;/a&gt; a technical solution for this verbosity problem.&lt;/p&gt; &lt;p&gt;Again, I don’t understand this logic. If I want to do something when method &lt;code&gt;save()&lt;/code&gt; fails, I catch the exception and handle the situation somehow. If I don’t want to do that, I just say my method also &lt;code&gt;throws&lt;/code&gt; and pay no attention to exception handling. What is the problem? Where is the verbosity coming from?&lt;/p&gt; &lt;p&gt;I have an answer here, too. It’s coming from the existence of unchecked exceptions. We simply can’t always ignore failure, because the interfaces we’re using don’t allow us to do this. That’s all. For example, class &lt;a href=&quot;http://docs.oracle.com/javase/7/docs/api/java/lang/Runnable.html&quot;&gt;&lt;code&gt;Runnable&lt;/code&gt;&lt;/a&gt;, which is widely used for multi-thread programming, has method &lt;code&gt;run()&lt;/code&gt; that is not supposed to throw anything. That’s why we always have to catch everything inside the method and rethrow checked exceptions as unchecked.&lt;/p&gt; &lt;p&gt;If all methods in all Java &lt;a href=&quot;/2016/04/26/why-inputstream-design-is-wrong.html&quot;&gt;interfaces&lt;/a&gt; would be declared either as “safe” (&lt;code&gt;throws&lt;/code&gt; nothing) or “unsafe” (&lt;code&gt;throws Exception&lt;/code&gt;), everything would become logical and clear. If you want to stay “safe,” take responsibility for failure handling. Otherwise, be “unsafe” and let your users worry about safety.&lt;/p&gt; &lt;p&gt;No noise, very clean code, and obvious logic.&lt;/p&gt; &lt;h2 id=&quot;inappropriately-exposed-implementation-details&quot;&gt;Inappropriately Exposed Implementation Details&lt;/h2&gt; &lt;p&gt;&lt;a href=&quot;http://www.ibm.com/developerworks/library/j-jtp05254/&quot;&gt;Some say&lt;/a&gt; the ability to put a checked exception into &lt;code&gt;throws&lt;/code&gt; in the method signature instead of catching it here and rethrowing a new type encourages us to have too many irrelevant exception types in method signatures. For example, our method &lt;code&gt;save()&lt;/code&gt; may declare that it may throw &lt;code&gt;OutOfMemoryException&lt;/code&gt;, even though it seems to have nothing to do with memory allocation. But it does allocate some memory, right? So such a memory overflow may happen during a file saving operation.&lt;/p&gt; &lt;p&gt;Yet again, I don’t get the logic of this argument. If all exceptions are checked, and we don’t have multiple exception types, we just throw &lt;code&gt;Exception&lt;/code&gt; everywhere, and that’s it. Why do we need to care about the exception type in the first place? If we don’t use exceptions to control flow, we won’t do this.&lt;/p&gt; &lt;p&gt;If we really want to make our application memory overflow-resistant, we will introduce some memory manager, which will have something like the &lt;code&gt;bigEnough()&lt;/code&gt; method, which will tell us whether our heap is big enough for the next operation. Using exceptions in such situations is a totally inappropriate approach to exception management in OOP.&lt;/p&gt; &lt;h2 id=&quot;recoverable-exceptions&quot;&gt;Recoverable Exceptions&lt;/h2&gt; &lt;p&gt;Joshua Bloch, in &lt;a href=&quot;http://amzn.to/2crH5tW&quot;&gt;Effective Java&lt;/a&gt;, says to “use checked exceptions for recoverable conditions and runtime exceptions for programming errors.” He means something like this:&lt;/p&gt; &lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;save&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;file&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Exception&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ex&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// We can&amp;#39;t save the file, but it&amp;#39;s OK&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Let&amp;#39;s move on and do something else&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt; &lt;p&gt;How is that any different from a famous anti-pattern called &lt;a href=&quot;http://c2.com/cgi/wiki?DontUseExceptionsForFlowControl&quot;&gt;Don’t Use Exceptions for Flow Control&lt;/a&gt;? Joshua, with all due respect, you’re wrong. There are no such things as recoverable conditions in OOP. An exception indicates that the execution of a chain of calls from method to method is broken, and it’s time to go up through the chain and stop somewhere. But we never go back again after the exception:&lt;/p&gt; &lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;App#run() Data#update() Data#write() File#save() &amp;lt;-- Boom, there&amp;#39;s a failure here, so we go up&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt; &lt;p&gt;We can start this chain again, but we don’t go back after &lt;code&gt;throw&lt;/code&gt;. In other words, we don’t &lt;strong&gt;do&lt;/strong&gt; anything in the &lt;code&gt;catch&lt;/code&gt; block. We only report the problem and wrap up execution. We never “recover!”&lt;/p&gt; &lt;hr /&gt; &lt;p&gt;All arguments against checked exceptions demonstrate nothing but a serious misunderstanding of object-oriented programming by their authors. The mistake in Java and in many other languages is the existence of unchecked exceptions, not checked ones.&lt;/p&gt; " /> <meta name="keywords" content="next, path, output, content, previous, url, relative_path, id, collection, excerpt, draft, categories, layout, title, date, tags, place, description, keywords, book, image, jb_picture, slug, ext" /> <meta name="viewport" content="width=device-width,minimum-scale=1,initial-scale=1"/> <meta name="google-site-verification" content="JEj_gQr2CPe2QKGw8XdMz0R7VboQIUbX3FlM-lwTq-8" /> <meta name="author" content="Yegor Bugayenko"> <meta name="article:published_time" content="2015-07-28 00:00:00 +0000"> <meta name="og:site_name" content="Yegor Bugayenko"/> <meta name="og:type" content="article" /> <meta name="og:locale" content="en_US" /> <meta name="twitter:account_id" content="4503599630178231" /> <meta name="twitter:creator" content="@yegor256"/> <meta name="twitter:site" content="@yegor256"/> <meta name="twitter:title" property="og:title" content="Checked vs. Unchecked Exceptions: The Debate Is Not Over"/> <meta name="twitter:description" property="og:description" content="&lt;p&gt;Do we need checked exceptions at all? The &lt;a href=&quot;http://stackoverflow.com/questions/6115896/java-checked-vs-unchecked-exception-explanation&quot;&gt;debate&lt;/a&gt; is over, isn’t it? Not for me. While most object-oriented languages don’t have them, and most programmers think checked exceptions are a Java mistake, I believe in the opposite—unchecked exceptions are the &lt;strong&gt;mistake&lt;/strong&gt;. Moreover, I believe multiple exception types are a bad idea too.&lt;/p&gt; &lt;!--more--&gt; &lt;figure class=&quot;jb_picture&quot;&gt;&lt;img itemprop=&quot;image&quot; alt=&quot;True Romance (1993) by Tony Scott&quot; src=&quot;/images/2015/07/true-romance.jpg&quot; longdesc=&quot;#443dfa82&quot; /&gt;&lt;figcaption id=&quot;443dfa82&quot;&gt;True Romance (1993) by Tony Scott&lt;/figcaption&gt;&lt;/figure&gt; &lt;p&gt;Let me first explain how I understand exceptions in object-oriented programming. Then I’ll compare my understanding with a “traditional” approach, and we’ll discuss the differences. So, my understanding first.&lt;/p&gt; &lt;p&gt;Say there is a method that saves some binary data to a file:&lt;/p&gt; &lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;save&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;File&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;file&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;byte&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;throws&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Exception&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// save data to the file&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt; &lt;p&gt;When everything goes right, the method just saves the data and returns control. When something is wrong, it &lt;a href=&quot;/2015/12/01/rethrow-exceptions.html&quot;&gt;throws&lt;/a&gt; &lt;code&gt;Exception&lt;/code&gt; and we have to do something about it:&lt;/p&gt; &lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;save&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;file&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Exception&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ex&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;Sorry, we can&amp;#39;t save right now.&amp;quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt; &lt;p&gt;When a method says it &lt;code&gt;throws&lt;/code&gt; an exception, I understand that the method is not &lt;strong&gt;safe&lt;/strong&gt;. It may fail sometimes, and it’s my responsibility to either 1) handle this failure or 2) declare myself as &lt;strong&gt;unsafe&lt;/strong&gt; too.&lt;/p&gt; &lt;p&gt;I know each method is designed with a &lt;a href=&quot;https://en.wikipedia.org/wiki/Single_responsibility_principle&quot;&gt;single responsibility principle&lt;/a&gt; in mind. This is a guarantee to me that if method &lt;code&gt;save()&lt;/code&gt; fails, it means the entire saving operation can’t be completed. If I need to know what the cause of this failure was, I will &lt;a href=&quot;https://en.wikipedia.org/wiki/Exception_chaining&quot;&gt;un-chain&lt;/a&gt; the exception—traverse the stack of chained exceptions and stack traces encapsulated in &lt;code&gt;ex&lt;/code&gt;.&lt;/p&gt; &lt;p&gt;I never use exceptions for flow control, which means I &lt;strong&gt;never recover&lt;/strong&gt; situations where exceptions are thrown. When an exception occurs, I let it float up to the highest level of the application. Sometimes I &lt;a href=&quot;/2015/12/01/rethrow-exceptions.html&quot;&gt;rethrow&lt;/a&gt; it in order to add more semantic information to the chain. That’s why it doesn’t matter to me what the cause of the exception thrown by &lt;code&gt;save()&lt;/code&gt; was. I just know the method failed. That’s enough for me. Always.&lt;/p&gt; &lt;p&gt;For the same reason, I don’t need to differentiate between different exception types. I just don’t need that type of hierarchy. &lt;code&gt;Exception&lt;/code&gt; is enough for me. Again, that’s because I don’t use exceptions for flow control.&lt;/p&gt; &lt;p&gt;That’s how I understand exceptions.&lt;/p&gt; &lt;p&gt;According to this paradigm, I would say we must:&lt;/p&gt; &lt;ul&gt; &lt;li&gt;Always use checked exceptions.&lt;/li&gt; &lt;li&gt;Never throw/use unchecked exceptions.&lt;/li&gt; &lt;li&gt;Use only &lt;code&gt;Exception&lt;/code&gt;, without any sub-types.&lt;/li&gt; &lt;li&gt;Always declare one exception type in the &lt;code&gt;throws&lt;/code&gt; block.&lt;/li&gt; &lt;li&gt;Never catch without rethrowing; read &lt;a href=&quot;/2015/07/09/catch-if-cant-otherwise.html&quot;&gt;more about that here&lt;/a&gt;.&lt;/li&gt; &lt;/ul&gt; &lt;p&gt;This paradigm diverges from many other articles I’ve found on this subject. Let’s compare and discuss.&lt;/p&gt; &lt;h2 id=&quot;runtime-vs-api-exceptions&quot;&gt;Runtime vs. API Exceptions&lt;/h2&gt; &lt;p&gt;&lt;a href=&quot;http://docs.oracle.com/javase/tutorial/essential/exceptions/runtime.html&quot;&gt;Oracle says&lt;/a&gt; some exceptions should be part of API (checked ones) while some are runtime exceptions and should not be part of it (unchecked). They will be documented in JavaDoc but not in the method signature.&lt;/p&gt; &lt;p&gt;I don’t understand the logic here, and I’m sure Java designers don’t understand it either. How and why are some exceptions important while others are not? Why do some of them deserve a proper API position in the &lt;code&gt;throws&lt;/code&gt; block of the method signature while others don’t? What is the criteria?&lt;/p&gt; &lt;p&gt;I have an answer here, though. By introducing checked and unchecked exceptions, Java developers tried to solve the problem of methods that are too complex and messy. When a method is too big and does too many things at the same time (violates the single responsibility principle), it’s definitely better to let us keep some exceptions “hidden” (a.k.a. unchecked). But it’s not a real solution. It is only a temporary patch that does all of us more harm than good—methods keep growing in size and complexity.&lt;/p&gt; &lt;p&gt;Unchecked exceptions are a mistake in Java design, not &lt;a href=&quot;/2015/10/20/interrupted-exception.html&quot;&gt;checked&lt;/a&gt; ones.&lt;/p&gt; &lt;p&gt;Hiding the fact that a method may fail at some point is a mistake. That’s exactly what unchecked exceptions do.&lt;/p&gt; &lt;p&gt;Instead, we should make this fact visible. When a method does too many things, there will be too many points of failure, and the author of the method will realize that something is wrong—a method should not throw exceptions in so many situations. This will lead to refactoring. The existence of unchecked exceptions leads to a mess. By the way, checked exceptions don’t exist at all in Ruby, C#, Python, PHP, etc. This means that creators of these languages understand &lt;a href=&quot;/2016/08/15/what-is-wrong-object-oriented-programming.html&quot;&gt;OOP&lt;/a&gt; even less than Java authors.&lt;/p&gt; &lt;h2 id=&quot;checked-exceptions-are-too-noisy&quot;&gt;Checked Exceptions Are Too Noisy&lt;/h2&gt; &lt;p&gt;Another common argument against checked exceptions is that they make our code more verbose. We have to put &lt;code&gt;try/catch&lt;/code&gt; everywhere instead of staying focused on the main logic. Bozhidar Bozhanov even &lt;a href=&quot;http://techblog.bozho.net/checked-and-unchecked-exceptions-in-java/&quot;&gt;suggests&lt;/a&gt; a technical solution for this verbosity problem.&lt;/p&gt; &lt;p&gt;Again, I don’t understand this logic. If I want to do something when method &lt;code&gt;save()&lt;/code&gt; fails, I catch the exception and handle the situation somehow. If I don’t want to do that, I just say my method also &lt;code&gt;throws&lt;/code&gt; and pay no attention to exception handling. What is the problem? Where is the verbosity coming from?&lt;/p&gt; &lt;p&gt;I have an answer here, too. It’s coming from the existence of unchecked exceptions. We simply can’t always ignore failure, because the interfaces we’re using don’t allow us to do this. That’s all. For example, class &lt;a href=&quot;http://docs.oracle.com/javase/7/docs/api/java/lang/Runnable.html&quot;&gt;&lt;code&gt;Runnable&lt;/code&gt;&lt;/a&gt;, which is widely used for multi-thread programming, has method &lt;code&gt;run()&lt;/code&gt; that is not supposed to throw anything. That’s why we always have to catch everything inside the method and rethrow checked exceptions as unchecked.&lt;/p&gt; &lt;p&gt;If all methods in all Java &lt;a href=&quot;/2016/04/26/why-inputstream-design-is-wrong.html&quot;&gt;interfaces&lt;/a&gt; would be declared either as “safe” (&lt;code&gt;throws&lt;/code&gt; nothing) or “unsafe” (&lt;code&gt;throws Exception&lt;/code&gt;), everything would become logical and clear. If you want to stay “safe,” take responsibility for failure handling. Otherwise, be “unsafe” and let your users worry about safety.&lt;/p&gt; &lt;p&gt;No noise, very clean code, and obvious logic.&lt;/p&gt; &lt;h2 id=&quot;inappropriately-exposed-implementation-details&quot;&gt;Inappropriately Exposed Implementation Details&lt;/h2&gt; &lt;p&gt;&lt;a href=&quot;http://www.ibm.com/developerworks/library/j-jtp05254/&quot;&gt;Some say&lt;/a&gt; the ability to put a checked exception into &lt;code&gt;throws&lt;/code&gt; in the method signature instead of catching it here and rethrowing a new type encourages us to have too many irrelevant exception types in method signatures. For example, our method &lt;code&gt;save()&lt;/code&gt; may declare that it may throw &lt;code&gt;OutOfMemoryException&lt;/code&gt;, even though it seems to have nothing to do with memory allocation. But it does allocate some memory, right? So such a memory overflow may happen during a file saving operation.&lt;/p&gt; &lt;p&gt;Yet again, I don’t get the logic of this argument. If all exceptions are checked, and we don’t have multiple exception types, we just throw &lt;code&gt;Exception&lt;/code&gt; everywhere, and that’s it. Why do we need to care about the exception type in the first place? If we don’t use exceptions to control flow, we won’t do this.&lt;/p&gt; &lt;p&gt;If we really want to make our application memory overflow-resistant, we will introduce some memory manager, which will have something like the &lt;code&gt;bigEnough()&lt;/code&gt; method, which will tell us whether our heap is big enough for the next operation. Using exceptions in such situations is a totally inappropriate approach to exception management in OOP.&lt;/p&gt; &lt;h2 id=&quot;recoverable-exceptions&quot;&gt;Recoverable Exceptions&lt;/h2&gt; &lt;p&gt;Joshua Bloch, in &lt;a href=&quot;http://amzn.to/2crH5tW&quot;&gt;Effective Java&lt;/a&gt;, says to “use checked exceptions for recoverable conditions and runtime exceptions for programming errors.” He means something like this:&lt;/p&gt; &lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;save&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;file&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Exception&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ex&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// We can&amp;#39;t save the file, but it&amp;#39;s OK&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Let&amp;#39;s move on and do something else&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt; &lt;p&gt;How is that any different from a famous anti-pattern called &lt;a href=&quot;http://c2.com/cgi/wiki?DontUseExceptionsForFlowControl&quot;&gt;Don’t Use Exceptions for Flow Control&lt;/a&gt;? Joshua, with all due respect, you’re wrong. There are no such things as recoverable conditions in OOP. An exception indicates that the execution of a chain of calls from method to method is broken, and it’s time to go up through the chain and stop somewhere. But we never go back again after the exception:&lt;/p&gt; &lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;App#run() Data#update() Data#write() File#save() &amp;lt;-- Boom, there&amp;#39;s a failure here, so we go up&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt; &lt;p&gt;We can start this chain again, but we don’t go back after &lt;code&gt;throw&lt;/code&gt;. In other words, we don’t &lt;strong&gt;do&lt;/strong&gt; anything in the &lt;code&gt;catch&lt;/code&gt; block. We only report the problem and wrap up execution. We never “recover!”&lt;/p&gt; &lt;hr /&gt; &lt;p&gt;All arguments against checked exceptions demonstrate nothing but a serious misunderstanding of object-oriented programming by their authors. The mistake in Java and in many other languages is the existence of unchecked exceptions, not checked ones.&lt;/p&gt; "/> <meta name="twitter:url" property="og:url" content="https://www.yegor256.com/2015/07/28/checked-vs-unchecked-exceptions.html"/> <meta name="telegram:channel" content="AAAAAEJFMRzsRTRxM3ec6A"/> <link rel="search" type="application/opensearchdescription+xml" href="/opensearch.xml" title="yegor256" /> <link rel="shortcut icon" href="/favicon.ico?c998b88f617"/> <link rel="apple-touch-icon" href="/favicon.ico?c998b88f617"/> <link rel="alternate" type="application/rss+xml" title="RSS for yegor256.com" href="https://www.yegor256.com/rss.xml"/> <link rel="stylesheet" href="/css/layout.css?c998b88f617"/> <link rel="stylesheet" href="/css/icons.css?c998b88f617"/> <link rel="canonical" href="https://www.yegor256.com/2015/07/28/checked-vs-unchecked-exceptions.html" /> <link rel="amphtml" href="https://www.yegor256.com/2015/07/28/checked-vs-unchecked-exceptions.amp.html" /> <title>Checked vs. Unchecked Exceptions: The Debate Is Not Over </title> <meta name='og:image' content='https://www.yegor256.com/images/2015/07/true-romance.jpg'/><meta name='twitter:image' content='https://www.yegor256.com/images/2015/07/true-romance.jpg'/><meta name='og:image:width' content='1200'/> <meta name='twitter:image:width' content='1200'/><meta name='og:image:height' content='496'/> <meta name='twitter:image:height' content='496'/><meta name='twitter:card' content='summary_large_image'/><meta name='twitter:image:alt' content='True Romance (1993) by Tony Scott'/> </head> <body><div class="wrapper"> <aside class="header-toggle unprintable" id="header-toggle" title="Show the menu" onclick="$('#header').show();$('#header-toggle').hide();">&#9776;</aside> <header class="header" id="header"><div class="face"> <a href="/about-me.html#form" class="sub" title="Click to subscribe to my monthly newsletter"><span>Subscribe</span></a> <a href="/about-me.html" style="position:relative;"> <img src="/images/face-256x256.jpg" class="photo" alt="Yegor Bugayenko"/> </a></div><nav><ul class="menu social notranslate"> <li><a href="https://twitter.com/intent/follow?screen_name=yegor256" rel="nofollow" title="Follow me on Twitter"><i class="icon icon-twitter notranslate" aria-hidden="true"></i></a></li> <li><a href="/rss.xml" rel="nofollow" title="Subscribe to my RSS feed"><i class="icon icon-rss notranslate" aria-hidden="true"></i></a></li> <li><a itemprop="sameAs" href="https://github.com/yegor256" rel="nofollow" title="My GitHub profile"><i class="icon icon-github notranslate" aria-hidden="true"></i></a></li> <li><a itemprop="sameAs" href="http://stackoverflow.com/users/187141/yegor256" rel="nofollow" title="My StackOverflow profile"><i class="icon icon-stackoverflow notranslate" aria-hidden="true"></i></a></li> <li><a itemprop="sameAs" href="https://www.facebook.com/yegor256" rel="nofollow" title="Follow me on Facebook"><i class="icon icon-facebook notranslate" aria-hidden="true"></i></a></li> <li><a itemprop="sameAs" href="https://instagram.com/yegor256" rel="nofollow" title="Follow me on Instagram"><i class="icon icon-instagram notranslate" aria-hidden="true"></i></a></li> <li><a itemprop="sameAs" href="https://www.linkedin.com/in/yegor256" rel="nofollow" title="My LinkedIn profile"><i class="icon icon-linkedin notranslate" aria-hidden="true"></i></a></li> <li><a itemprop="sameAs" href="https://www.youtube.com/c/yegor256?sub_confirmation=1" rel="nofollow" title="My Youtube video channel"><i class="icon icon-youtube notranslate" aria-hidden="true"></i></a></li> <li><a itemprop="sameAs" href="https://www.pinterest.com/yegor256/" rel="nofollow" title="My Pinterest boards"><i class="icon icon-pinterest notranslate" aria-hidden="true"></i></a></li> <li><a itemprop="sameAs" href="https://angel.co/yegor256" rel="nofollow" title="My AngelList profile"><i class="icon icon-angellist notranslate" aria-hidden="true"></i></a></li> <li><a href="https://soundcloud.com/yegor256" rel="nofollow" title="My podcast"><i class="icon icon-podcast notranslate" aria-hidden="true"></i></a></li> <li><a href="https://itunes.apple.com/us/podcast/yegor256-podcast/id1150826721" rel="nofollow" title="My iTunes podcast"><i class="icon icon-itunes notranslate" aria-hidden="true"></i></a></li> <li><a href="https://t.me/yegor256news" rel="nofollow" title="My Telegram public channel"><i class="icon icon-telegram notranslate" aria-hidden="true"></i></a></li> <li><a href="mailto:blog@yegor256.com" rel="nofollow" title="Email me any time"><i class="icon icon-mail notranslate" aria-hidden="true"></i></a></li></ul><ul class="menu"> <li><a href="/" title="Home page">Home</a></li> <li /2015/07/28/checked-vs-unchecked-exceptions.html><a href="/best.html" title="Best articles to read">12&#160;Best</a></li> <li /2015/07/28/checked-vs-unchecked-exceptions.html><a href="/contents.html" title="The contents of the entire blog">All&#160;292</a></li> <li /2015/07/28/checked-vs-unchecked-exceptions.html><a href="/webinars.html" title="My webinars">Webinars</a></li> <li /2015/07/28/checked-vs-unchecked-exceptions.html><a href="/talks.html" title="Future and past conference talks">Talks</a></li> <li /2015/07/28/checked-vs-unchecked-exceptions.html><a href="/books.html" title="The books I wrote">Books</a></li> <li /2015/07/28/checked-vs-unchecked-exceptions.html><a href="/papers.html" title="My academic papers and patents">Papers</a></li> <li /2015/07/28/checked-vs-unchecked-exceptions.html><a href="/pets.html" title="My loved pet projects">Pets</a></li> <li /2015/07/28/checked-vs-unchecked-exceptions.html class="highlighted"><a href="/trainings.html" title="On-site trainings">Trainings</a></li> <li /2015/07/28/checked-vs-unchecked-exceptions.html><a href="/award.html" title="Software quality award">Award</a></li> <li /2015/07/28/checked-vs-unchecked-exceptions.html><a href="/testimonials.html" title="What some people say about me">Testimonials</a></li> <li /2015/07/28/checked-vs-unchecked-exceptions.html><a href="/shift-m.html" title="Audio podcast about project management">Shift-M</a></li> <li /2015/07/28/checked-vs-unchecked-exceptions.html><a href="/paintings.html" title="My paintings for sale">Paintings</a></li> <li><a href="https://ru.yegor256.com/" title="Немного на русском языке">По-русски</a></li></ul></nav><div class="search"> <form method="get" action="https://www.google.com/search" itemprop="potentialAction" itemscope="" itemtype="http://schema.org/SearchAction"> <meta itemprop="target" content="https://www.google.com/search?q={q}"/> <input name="sitesearch" value="yegor256.com" type="hidden"/> <input itemprop="query-input" type="text" id="search-query" class="field field-text" required="required" onfocus="$('.google').css('visibility', 'visible');" name="q" placeholder="Search..." autocomplete="off"/> <input type="image" src="/images/google-search-icon.svg" class="google" title="Search via Google" alt="Search via Google"/> </form></div><div class="hot"><ul></ul></div></header></div><section itemscope="" itemtype="http://schema.org/BlogPosting"><div class="wrapper"> <header><p class="printable"> <img src="https://api.qrserver.com/v1/create-qr-code/?data=https://www.yegor256.com/2015/07/28/checked-vs-unchecked-exceptions.html&amp;format=svg" style="width:125px;height:125px;" alt="QR code"/></p><p class="printable"> <code itemprop="url">https://www.yegor256.com/2015/07/28/checked-vs-unchecked-exceptions.html</code></p><h1 itemprop="name headline mainEntityOfPage">Checked vs. Unchecked Exceptions: The Debate Is Not Over</h1><aside class='book'><a href='http://amzn.to/2qFt4Tn'><img src='/images/books/elegant-objects/cover.png' class='book-cover' alt='book cover'/></a>Read more about this subject in <a href='http://amzn.to/2qFt4Tn'>Section&nbsp;4.2</a><br/> of my book<a href='http://amzn.to/2qFt4Tn'><img src='/images/books/amazon-buy-button.png' class='amazon-button' alt='Click to buy'/></a></aside><ul class="subline"> <li> <time itemprop="datePublished" datetime="2015-07-28T00:00:00+00:00"> 28 July 2015 </time> </li> <li class="desktop-only" itemprop="locationCreated">Sunnyvale, CA</li> <li class="printable" itemscope="" itemprop="author" itemtype="http://schema.org/Person"> <span itemprop="name">Yegor Bugayenko</span> </li> <li class="unprintable"> <i class="icon icon-comments"></i> <a href="https://www.yegor256.com/2015/07/28/checked-vs-unchecked-exceptions.html#disqus_thread" itemprop="discussionUrl">comments</a> </li></ul><p class="unprintable"><p>Do we need checked exceptions at all? The <a href="http://stackoverflow.com/questions/6115896/java-checked-vs-unchecked-exception-explanation">debate</a> is over, isn’t it? Not for me. While most object-oriented languages don’t have them, and most programmers think checked exceptions are a Java mistake, I believe in the opposite—unchecked exceptions are the <strong>mistake</strong>. Moreover, I believe multiple exception types are a bad idea too.</p><figure class="jb_picture"><img itemprop="image" alt="True Romance (1993) by Tony Scott" src="/images/2015/07/true-romance.jpg" longdesc="#443dfa82" /><figcaption id="443dfa82">True Romance (1993) by Tony Scott</figcaption></figure><p>Let me first explain how I understand exceptions in object-oriented programming. Then I’ll compare my understanding with a “traditional” approach, and we’ll discuss the differences. So, my understanding first.</p><p>Say there is a method that saves some binary data to a file:</p><figure class="highlight"><pre><code class="language-java" data-lang="java"><span></span><span class="kd">public</span> <span class="kt">void</span> <span class="nf">save</span><span class="o">(</span><span class="n">File</span> <span class="n">file</span><span class="o">,</span> <span class="kt">byte</span><span class="o">[]</span> <span class="n">data</span><span class="o">)</span>
  <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>
  <span class="c1">// save data to the file</span>
<span class="o">}</span></code></pre></figure><p>When everything goes right, the method just saves the data and returns control. When something is wrong, it <a href="/2015/12/01/rethrow-exceptions.html">throws</a> <code>Exception</code> and we have to do something about it:</p><figure class="highlight"><pre><code class="language-java" data-lang="java"><span></span><span class="k">try</span> <span class="o">{</span>
  <span class="n">save</span><span class="o">(</span><span class="n">file</span><span class="o">,</span> <span class="n">data</span><span class="o">);</span>
<span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">Exception</span> <span class="n">ex</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;Sorry, we can&#39;t save right now.&quot;</span><span class="o">);</span>
<span class="o">}</span></code></pre></figure><p>When a method says it <code>throws</code> an exception, I understand that the method is not <strong>safe</strong>. It may fail sometimes, and it’s my responsibility to either 1) handle this failure or 2) declare myself as <strong>unsafe</strong> too.</p><p>I know each method is designed with a <a href="https://en.wikipedia.org/wiki/Single_responsibility_principle">single responsibility principle</a> in mind. This is a guarantee to me that if method <code>save()</code> fails, it means the entire saving operation can’t be completed. If I need to know what the cause of this failure was, I will <a href="https://en.wikipedia.org/wiki/Exception_chaining">un-chain</a> the exception—traverse the stack of chained exceptions and stack traces encapsulated in <code>ex</code>.</p><p>I never use exceptions for flow control, which means I <strong>never recover</strong> situations where exceptions are thrown. When an exception occurs, I let it float up to the highest level of the application. Sometimes I <a href="/2015/12/01/rethrow-exceptions.html">rethrow</a> it in order to add more semantic information to the chain. That’s why it doesn’t matter to me what the cause of the exception thrown by <code>save()</code> was. I just know the method failed. That’s enough for me. Always.</p><p>For the same reason, I don’t need to differentiate between different exception types. I just don’t need that type of hierarchy. <code>Exception</code> is enough for me. Again, that’s because I don’t use exceptions for flow control.</p><p>That’s how I understand exceptions.</p><p>According to this paradigm, I would say we must:</p><ul> <li>Always use checked exceptions.</li> <li>Never throw/use unchecked exceptions.</li> <li>Use only <code>Exception</code>, without any sub-types.</li> <li>Always declare one exception type in the <code>throws</code> block.</li> <li>Never catch without rethrowing; read <a href="/2015/07/09/catch-if-cant-otherwise.html">more about that here</a>.</li></ul><p>This paradigm diverges from many other articles I’ve found on this subject. Let’s compare and discuss.</p><h2 id="runtime-vs-api-exceptions">Runtime vs. API Exceptions</h2><p><a href="http://docs.oracle.com/javase/tutorial/essential/exceptions/runtime.html">Oracle says</a> some exceptions should be part of API (checked ones) while some are runtime exceptions and should not be part of it (unchecked). They will be documented in JavaDoc but not in the method signature.</p><p>I don’t understand the logic here, and I’m sure Java designers don’t understand it either. How and why are some exceptions important while others are not? Why do some of them deserve a proper API position in the <code>throws</code> block of the method signature while others don’t? What is the criteria?</p><p>I have an answer here, though. By introducing checked and unchecked exceptions, Java developers tried to solve the problem of methods that are too complex and messy. When a method is too big and does too many things at the same time (violates the single responsibility principle), it’s definitely better to let us keep some exceptions “hidden” (a.k.a. unchecked). But it’s not a real solution. It is only a temporary patch that does all of us more harm than good—methods keep growing in size and complexity.</p><p>Unchecked exceptions are a mistake in Java design, not <a href="/2015/10/20/interrupted-exception.html">checked</a> ones.</p><p>Hiding the fact that a method may fail at some point is a mistake. That’s exactly what unchecked exceptions do.</p><p>Instead, we should make this fact visible. When a method does too many things, there will be too many points of failure, and the author of the method will realize that something is wrong—a method should not throw exceptions in so many situations. This will lead to refactoring. The existence of unchecked exceptions leads to a mess. By the way, checked exceptions don’t exist at all in Ruby, C#, Python, PHP, etc. This means that creators of these languages understand <a href="/2016/08/15/what-is-wrong-object-oriented-programming.html">OOP</a> even less than Java authors.</p><h2 id="checked-exceptions-are-too-noisy">Checked Exceptions Are Too Noisy</h2><p>Another common argument against checked exceptions is that they make our code more verbose. We have to put <code>try/catch</code> everywhere instead of staying focused on the main logic. Bozhidar Bozhanov even <a href="http://techblog.bozho.net/checked-and-unchecked-exceptions-in-java/">suggests</a> a technical solution for this verbosity problem.</p><p>Again, I don’t understand this logic. If I want to do something when method <code>save()</code> fails, I catch the exception and handle the situation somehow. If I don’t want to do that, I just say my method also <code>throws</code> and pay no attention to exception handling. What is the problem? Where is the verbosity coming from?</p><p>I have an answer here, too. It’s coming from the existence of unchecked exceptions. We simply can’t always ignore failure, because the interfaces we’re using don’t allow us to do this. That’s all. For example, class <a href="http://docs.oracle.com/javase/7/docs/api/java/lang/Runnable.html"><code>Runnable</code></a>, which is widely used for multi-thread programming, has method <code>run()</code> that is not supposed to throw anything. That’s why we always have to catch everything inside the method and rethrow checked exceptions as unchecked.</p><p>If all methods in all Java <a href="/2016/04/26/why-inputstream-design-is-wrong.html">interfaces</a> would be declared either as “safe” (<code>throws</code> nothing) or “unsafe” (<code>throws Exception</code>), everything would become logical and clear. If you want to stay “safe,” take responsibility for failure handling. Otherwise, be “unsafe” and let your users worry about safety.</p><p>No noise, very clean code, and obvious logic.</p><h2 id="inappropriately-exposed-implementation-details">Inappropriately Exposed Implementation Details</h2><p><a href="http://www.ibm.com/developerworks/library/j-jtp05254/">Some say</a> the ability to put a checked exception into <code>throws</code> in the method signature instead of catching it here and rethrowing a new type encourages us to have too many irrelevant exception types in method signatures. For example, our method <code>save()</code> may declare that it may throw <code>OutOfMemoryException</code>, even though it seems to have nothing to do with memory allocation. But it does allocate some memory, right? So such a memory overflow may happen during a file saving operation.</p><p>Yet again, I don’t get the logic of this argument. If all exceptions are checked, and we don’t have multiple exception types, we just throw <code>Exception</code> everywhere, and that’s it. Why do we need to care about the exception type in the first place? If we don’t use exceptions to control flow, we won’t do this.</p><p>If we really want to make our application memory overflow-resistant, we will introduce some memory manager, which will have something like the <code>bigEnough()</code> method, which will tell us whether our heap is big enough for the next operation. Using exceptions in such situations is a totally inappropriate approach to exception management in OOP.</p><h2 id="recoverable-exceptions">Recoverable Exceptions</h2><p>Joshua Bloch, in <a href="http://amzn.to/2crH5tW">Effective Java</a>, says to “use checked exceptions for recoverable conditions and runtime exceptions for programming errors.” He means something like this:</p><figure class="highlight"><pre><code class="language-java" data-lang="java"><span></span><span class="k">try</span> <span class="o">{</span>
  <span class="n">save</span><span class="o">(</span><span class="n">file</span><span class="o">,</span> <span class="n">data</span><span class="o">);</span>
<span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">Exception</span> <span class="n">ex</span><span class="o">)</span> <span class="o">{</span>
  <span class="c1">// We can&#39;t save the file, but it&#39;s OK</span>
  <span class="c1">// Let&#39;s move on and do something else</span>
<span class="o">}</span></code></pre></figure><p>How is that any different from a famous anti-pattern called <a href="http://c2.com/cgi/wiki?DontUseExceptionsForFlowControl">Don’t Use Exceptions for Flow Control</a>? Joshua, with all due respect, you’re wrong. There are no such things as recoverable conditions in OOP. An exception indicates that the execution of a chain of calls from method to method is broken, and it’s time to go up through the chain and stop somewhere. But we never go back again after the exception:</p><figure class="highlight"><pre><code class="language-text" data-lang="text"><span></span>App#run()
  Data#update()
    Data#write()
      File#save() &lt;-- Boom, there&#39;s a failure here, so we go up</code></pre></figure><p>We can start this chain again, but we don’t go back after <code>throw</code>. In other words, we don’t <strong>do</strong> anything in the <code>catch</code> block. We only report the problem and wrap up execution. We never “recover!”</p><hr /><p>All arguments against checked exceptions demonstrate nothing but a serious misunderstanding of object-oriented programming by their authors. The mistake in Java and in many other languages is the existence of unchecked exceptions, not checked ones.</p></p><nav class="buttons notranslate desktop-only"> <a href="http://www.facebook.com/sharer/sharer.php?u=https://www.yegor256.com/2015/07/28/checked-vs-unchecked-exceptions.html" title="Share on Facebook" class="button" rel="nofollow"> <span class="count count-facebook">0</span> <i class="icon icon-facebook notranslate" aria-hidden="true"></i> </a> <a href="https://twitter.com/share?url=https://www.yegor256.com/2015/07/28/checked-vs-unchecked-exceptions.html&amp;text=Checked+vs.+Unchecked+Exceptions%3A+The+Debate+Is+Not+Over" title="Share on Twitter" class="button" rel="nofollow"> <span class="count count-twitter">0</span> <i class="icon icon-twitter notranslate" aria-hidden="true"></i> </a> <a href="https://plus.google.com/share?url=https://www.yegor256.com/2015/07/28/checked-vs-unchecked-exceptions.html" title="Share on Google+" class="button" rel="nofollow"> <span class="count count-googleplus">0</span> <i class="icon icon-googleplus notranslate" aria-hidden="true"></i> </a> <a href="https://www.linkedin.com/cws/share?url=https://www.yegor256.com/2015/07/28/checked-vs-unchecked-exceptions.html" title="Share on LinkedIn" class="button" rel="nofollow"> <span class="count count-linkedin">0</span> <i class="icon icon-linkedin notranslate" aria-hidden="true"></i> </a> <a href="http://reddit.com/submit?url=https://www.yegor256.com/2015/07/28/checked-vs-unchecked-exceptions.html%3F2015-30&amp;title=Checked+vs.+Unchecked+Exceptions%3A+The+Debate+Is+Not+Over" title="Share on Reddit" class="button" rel="nofollow"> <span class="count count-reddit">0</span> <i class="icon icon-reddit notranslate" aria-hidden="true"></i> </a> <a href="http://news.ycombinator.com/submitlink?u=https://www.yegor256.com/2015/07/28/checked-vs-unchecked-exceptions.html%3F2015-30&amp;t=Checked+vs.+Unchecked+Exceptions%3A+The+Debate+Is+Not+Over" title="Share on Hacker News" class="button" rel="nofollow"> <span class="count count-hackernews">0</span> <i class="icon icon-hackernews notranslate" aria-hidden="true"></i> </a> </nav> </header> <article class="main" itemprop="articleBody"><div ><p>Do we need checked exceptions at all? The <a href="http://stackoverflow.com/questions/6115896/java-checked-vs-unchecked-exception-explanation">debate</a> is over, isn’t it? Not for me. While most object-oriented languages don’t have them, and most programmers think checked exceptions are a Java mistake, I believe in the opposite—unchecked exceptions are the <strong>mistake</strong>. Moreover, I believe multiple exception types are a bad idea too.</p><figure class="jb_picture"><img itemprop="image" alt="True Romance (1993) by Tony Scott" src="/images/2015/07/true-romance.jpg" longdesc="#443dfa82" /><figcaption id="443dfa82">True Romance (1993) by Tony Scott</figcaption></figure><p>Let me first explain how I understand exceptions in object-oriented programming. Then I’ll compare my understanding with a “traditional” approach, and we’ll discuss the differences. So, my understanding first.</p><p>Say there is a method that saves some binary data to a file:</p><figure class="highlight"><pre><code class="language-java" data-lang="java"><span></span><span class="kd">public</span> <span class="kt">void</span> <span class="nf">save</span><span class="o">(</span><span class="n">File</span> <span class="n">file</span><span class="o">,</span> <span class="kt">byte</span><span class="o">[]</span> <span class="n">data</span><span class="o">)</span>
  <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>
  <span class="c1">// save data to the file</span>
<span class="o">}</span></code></pre></figure><p>When everything goes right, the method just saves the data and returns control. When something is wrong, it <a href="/2015/12/01/rethrow-exceptions.html">throws</a> <code>Exception</code> and we have to do something about it:</p><figure class="highlight"><pre><code class="language-java" data-lang="java"><span></span><span class="k">try</span> <span class="o">{</span>
  <span class="n">save</span><span class="o">(</span><span class="n">file</span><span class="o">,</span> <span class="n">data</span><span class="o">);</span>
<span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">Exception</span> <span class="n">ex</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;Sorry, we can&#39;t save right now.&quot;</span><span class="o">);</span>
<span class="o">}</span></code></pre></figure><p>When a method says it <code>throws</code> an exception, I understand that the method is not <strong>safe</strong>. It may fail sometimes, and it’s my responsibility to either 1) handle this failure or 2) declare myself as <strong>unsafe</strong> too.</p><p>I know each method is designed with a <a href="https://en.wikipedia.org/wiki/Single_responsibility_principle">single responsibility principle</a> in mind. This is a guarantee to me that if method <code>save()</code> fails, it means the entire saving operation can’t be completed. If I need to know what the cause of this failure was, I will <a href="https://en.wikipedia.org/wiki/Exception_chaining">un-chain</a> the exception—traverse the stack of chained exceptions and stack traces encapsulated in <code>ex</code>.</p><p>I never use exceptions for flow control, which means I <strong>never recover</strong> situations where exceptions are thrown. When an exception occurs, I let it float up to the highest level of the application. Sometimes I <a href="/2015/12/01/rethrow-exceptions.html">rethrow</a> it in order to add more semantic information to the chain. That’s why it doesn’t matter to me what the cause of the exception thrown by <code>save()</code> was. I just know the method failed. That’s enough for me. Always.</p><p>For the same reason, I don’t need to differentiate between different exception types. I just don’t need that type of hierarchy. <code>Exception</code> is enough for me. Again, that’s because I don’t use exceptions for flow control.</p><p>That’s how I understand exceptions.</p><p>According to this paradigm, I would say we must:</p><ul> <li>Always use checked exceptions.</li> <li>Never throw/use unchecked exceptions.</li> <li>Use only <code>Exception</code>, without any sub-types.</li> <li>Always declare one exception type in the <code>throws</code> block.</li> <li>Never catch without rethrowing; read <a href="/2015/07/09/catch-if-cant-otherwise.html">more about that here</a>.</li></ul><p>This paradigm diverges from many other articles I’ve found on this subject. Let’s compare and discuss.</p><h2 id="runtime-vs-api-exceptions">Runtime vs. API Exceptions</h2><p><a href="http://docs.oracle.com/javase/tutorial/essential/exceptions/runtime.html">Oracle says</a> some exceptions should be part of API (checked ones) while some are runtime exceptions and should not be part of it (unchecked). They will be documented in JavaDoc but not in the method signature.</p><p>I don’t understand the logic here, and I’m sure Java designers don’t understand it either. How and why are some exceptions important while others are not? Why do some of them deserve a proper API position in the <code>throws</code> block of the method signature while others don’t? What is the criteria?</p><p>I have an answer here, though. By introducing checked and unchecked exceptions, Java developers tried to solve the problem of methods that are too complex and messy. When a method is too big and does too many things at the same time (violates the single responsibility principle), it’s definitely better to let us keep some exceptions “hidden” (a.k.a. unchecked). But it’s not a real solution. It is only a temporary patch that does all of us more harm than good—methods keep growing in size and complexity.</p><p>Unchecked exceptions are a mistake in Java design, not <a href="/2015/10/20/interrupted-exception.html">checked</a> ones.</p><p>Hiding the fact that a method may fail at some point is a mistake. That’s exactly what unchecked exceptions do.</p><p>Instead, we should make this fact visible. When a method does too many things, there will be too many points of failure, and the author of the method will realize that something is wrong—a method should not throw exceptions in so many situations. This will lead to refactoring. The existence of unchecked exceptions leads to a mess. By the way, checked exceptions don’t exist at all in Ruby, C#, Python, PHP, etc. This means that creators of these languages understand <a href="/2016/08/15/what-is-wrong-object-oriented-programming.html">OOP</a> even less than Java authors.</p><h2 id="checked-exceptions-are-too-noisy">Checked Exceptions Are Too Noisy</h2><p>Another common argument against checked exceptions is that they make our code more verbose. We have to put <code>try/catch</code> everywhere instead of staying focused on the main logic. Bozhidar Bozhanov even <a href="http://techblog.bozho.net/checked-and-unchecked-exceptions-in-java/">suggests</a> a technical solution for this verbosity problem.</p><p>Again, I don’t understand this logic. If I want to do something when method <code>save()</code> fails, I catch the exception and handle the situation somehow. If I don’t want to do that, I just say my method also <code>throws</code> and pay no attention to exception handling. What is the problem? Where is the verbosity coming from?</p><p>I have an answer here, too. It’s coming from the existence of unchecked exceptions. We simply can’t always ignore failure, because the interfaces we’re using don’t allow us to do this. That’s all. For example, class <a href="http://docs.oracle.com/javase/7/docs/api/java/lang/Runnable.html"><code>Runnable</code></a>, which is widely used for multi-thread programming, has method <code>run()</code> that is not supposed to throw anything. That’s why we always have to catch everything inside the method and rethrow checked exceptions as unchecked.</p><p>If all methods in all Java <a href="/2016/04/26/why-inputstream-design-is-wrong.html">interfaces</a> would be declared either as “safe” (<code>throws</code> nothing) or “unsafe” (<code>throws Exception</code>), everything would become logical and clear. If you want to stay “safe,” take responsibility for failure handling. Otherwise, be “unsafe” and let your users worry about safety.</p><p>No noise, very clean code, and obvious logic.</p><h2 id="inappropriately-exposed-implementation-details">Inappropriately Exposed Implementation Details</h2><p><a href="http://www.ibm.com/developerworks/library/j-jtp05254/">Some say</a> the ability to put a checked exception into <code>throws</code> in the method signature instead of catching it here and rethrowing a new type encourages us to have too many irrelevant exception types in method signatures. For example, our method <code>save()</code> may declare that it may throw <code>OutOfMemoryException</code>, even though it seems to have nothing to do with memory allocation. But it does allocate some memory, right? So such a memory overflow may happen during a file saving operation.</p><p>Yet again, I don’t get the logic of this argument. If all exceptions are checked, and we don’t have multiple exception types, we just throw <code>Exception</code> everywhere, and that’s it. Why do we need to care about the exception type in the first place? If we don’t use exceptions to control flow, we won’t do this.</p><p>If we really want to make our application memory overflow-resistant, we will introduce some memory manager, which will have something like the <code>bigEnough()</code> method, which will tell us whether our heap is big enough for the next operation. Using exceptions in such situations is a totally inappropriate approach to exception management in OOP.</p><h2 id="recoverable-exceptions">Recoverable Exceptions</h2><p>Joshua Bloch, in <a href="http://amzn.to/2crH5tW">Effective Java</a>, says to “use checked exceptions for recoverable conditions and runtime exceptions for programming errors.” He means something like this:</p><figure class="highlight"><pre><code class="language-java" data-lang="java"><span></span><span class="k">try</span> <span class="o">{</span>
  <span class="n">save</span><span class="o">(</span><span class="n">file</span><span class="o">,</span> <span class="n">data</span><span class="o">);</span>
<span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">Exception</span> <span class="n">ex</span><span class="o">)</span> <span class="o">{</span>
  <span class="c1">// We can&#39;t save the file, but it&#39;s OK</span>
  <span class="c1">// Let&#39;s move on and do something else</span>
<span class="o">}</span></code></pre></figure><p>How is that any different from a famous anti-pattern called <a href="http://c2.com/cgi/wiki?DontUseExceptionsForFlowControl">Don’t Use Exceptions for Flow Control</a>? Joshua, with all due respect, you’re wrong. There are no such things as recoverable conditions in OOP. An exception indicates that the execution of a chain of calls from method to method is broken, and it’s time to go up through the chain and stop somewhere. But we never go back again after the exception:</p><figure class="highlight"><pre><code class="language-text" data-lang="text"><span></span>App#run()
  Data#update()
    Data#write()
      File#save() &lt;-- Boom, there&#39;s a failure here, so we go up</code></pre></figure><p>We can start this chain again, but we don’t go back after <code>throw</code>. In other words, we don’t <strong>do</strong> anything in the <code>catch</code> block. We only report the problem and wrap up execution. We never “recover!”</p><hr /><p>All arguments against checked exceptions demonstrate nothing but a serious misunderstanding of object-oriented programming by their authors. The mistake in Java and in many other languages is the existence of unchecked exceptions, not checked ones.</p></div></article></div><div class="wrapper"> <related-posts /></div><div class="disqus" role="complementary"><p class="disqus_hint"> Please, use <a href="https://help.disqus.com/commenting/what-html-tags-are-allowed-within-comments">syntax highlighting</a> in your comments, to make them more readable.</p><div id="disqus_thread" class="disqus-thread"> <a>&nbsp;</a></div><script> var disqus_config = function () { this.page.url = document.location.href.split('?')[0].split('#')[0].replace('https://', 'http://'); this.page.identifier = this.page.url; }; (function() { var d = document, s = d.createElement('script'); s.src = '//yegor256.disqus.com/embed.js'; s.setAttribute('data-timestamp', +new Date()); (d.head || d.body).appendChild(s); })(); </script> <noscript><div><p class="red"> JavaScript is disabled in your browser, that's why you can't see comments under this post.</p></div></noscript></div><div class="wrapper"> <footer class="footer"><p> &copy; <span itemscope="" itemprop="copyrightHolder" itemtype="http://schema.org/Person"> <span itemprop="name">Yegor Bugayenko</span> </span> 2014&ndash;<span itemprop="copyrightYear">2018</span></p></footer></div></section><div class="wrapper unprintable" style="text-align:center;margin-top:2em;"> <a href="http://www.sixnines.io/h/3ba1652f"> <img src="//www.sixnines.io/b/3ba1652f?style=flat" alt="sixnines availability badge"/> </a></div><script src="//code.jquery.com/jquery-1.9.0.min.js"></script> <script src="/js/all.js?c998b88f617"></script> <script>var disqus_shortname = 'yegor256';</script> <script id="dsq-count-scr" src="//yegor256.disqus.com/count.js" async="async"></script> <script> (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){ (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o), m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m) })(window,document,'script','//www.google-analytics.com/analytics.js','ga'); ga('create', 'UA-1963507-32', 'auto'); ga('send', 'pageview'); </script> <script> Cd=document;Cr="&"+Math.random();Cp="&s=1"; Cd.cookie="b=b";if(Cd.cookie)Cp+="&c=1"; Cp+="&t="+(new Date()).getTimezoneOffset(); if(self!=top)Cp+="&f=1"; </script> <script> if(navigator.javaEnabled())Cp+="&j=1"; </script> <script> if(typeof(screen)!='undefined')Cp+="&w="+screen.width+"&h="+ screen.height+"&d="+(screen.colorDepth?screen.colorDepth:screen.pixelDepth); </script> <script> Cd.write("<img src='//c.hit.ua/hit?i=95870&g=0&x=2"+Cp+Cr+ "&r="+escape(Cd.referrer)+"&u="+escape(window.location.href)+ "' border='0' wi"+"dth='1' he"+"ight='1'/>"); </script> <script type="application/ld+json"> { "@context": "http://schema.org", "@type": "Person", "name": "Yegor Bugayenko", "url": "https://www.yegor256.com", "sameAs": [ "https://www.facebook.com/yegor256", "https://instagram.com/yegor256", "https://www.linkedin.com/in/yegor256", "https://twitter.com/yegor256", "https://github.com/yegor256", "https://www.pinterest.com/yegor256/" ] } </script> </body> </html>
