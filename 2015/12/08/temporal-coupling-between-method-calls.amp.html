<!DOCTYPE html>
<html amp lang="en">
  <head>

    <meta charset="utf-8">
    <title>Temporal Coupling Between Method Calls</title>
    <link rel="canonical" href="http://www.yegor256.com/2015/12/08/temporal-coupling-between-method-calls.html">
    <meta name="viewport" content="width=device-width,minimum-scale=1,initial-scale=1">
    <script type="application/ld+json">
      {
        "@context": "http://schema.org",
        "@type": "BlogPosting",
        "mainEntityOfPage":{
          "@type": "WebPage",
          "@id": "http://www.yegor256.com/2015/12/08/temporal-coupling-between-method-calls.html"
        },
        "headline": "Temporal Coupling Between Method Calls",
        "image": {
          "@type": "ImageObject",
          "url": "http://img.teamed.io/face-1400x1400.jpg",
          "height": 1400,
          "width": 1400
        },
        "datePublished": "2015-12-08",
        "dateModified": "2015-12-08",
        "author": {
          "@type": "Person",
          "name": "Yegor Bugayenko"
        },
        "publisher": {
          "@type": "Organization",
          "name": "yegor256.com",
          "logo": {
            "@type": "ImageObject",
            "url": "http://img.teamed.io/face-512x512.jpg",
            "width": 512,
            "height": 512
          }
        },
        "description": "Sequential method calls inevitably mean
temporal coupling, which is a bottleneck for
effective refactoring; avoid them.
",
        "keywords": ["temporal coupling", "temporal coupling java", "temporal coupling hidden", "temporal coupling in oop", "temporal coupling definition"]
      }
    </script>
    <style amp-boilerplate>body{-webkit-animation:-amp-start 8s steps(1,end) 0s 1 normal both;-moz-animation:-amp-start 8s steps(1,end) 0s 1 normal both;-ms-animation:-amp-start 8s steps(1,end) 0s 1 normal both;animation:-amp-start 8s steps(1,end) 0s 1 normal both}@-webkit-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-moz-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-ms-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-o-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}</style>
<noscript><style amp-boilerplate>body{-webkit-animation:none;-moz-animation:none;-ms-animation:none;animation:none}</style></noscript>
    <style amp-custom="amp-custom">
      body { padding: .5em; }
      article { width: 600px; max-width: 100%; margin-left: auto; margin-right: auto; }
      .intro { color: red; font-size: .75em; }
    </style>
    <script async src="https://cdn.ampproject.org/v0.js"></script>
  </head>
  <body>
    <article>
      <p class="intro">
        This is a mobile version of the article,
        its original content can be found
        <a href="http://www.yegor256.com/2015/12/08/temporal-coupling-between-method-calls.html">here</a>.
      </p>
      <h1>Temporal Coupling Between Method Calls</h1>
      <p>Temporal coupling happens between sequential method calls
when they must stay in a particular order. This is inevitable
in imperative programming, but we can reduce the negative effect
of it just by turning those static procedures into functions. Take
a look at this example.</p>





<p>Here is the code:</p>

<pre>class Foo {
  public List&lt;String&gt; names() {
    List&lt;String&gt; list = new LinkedList();
    Foo.append(list, "Jeff");
    Foo.append(list, "Walter");
    return list;
  }
  private static void append(
    List&lt;String&gt; list, String item) {
    list.add(item.toLowerCase());
  }
}</pre>

<p>What do you think about that? I believe it's clear what <code>names()</code> is doing—creating a list of names. In order to avoid duplication, there is a supplementary
<em>procedure</em>, <code>append()</code>, which converts an item to lowercase and adds it to the
list.</p>

<p>This is poor design.</p>

<p>It is a <strong>procedural</strong> design, and there is <strong>temporal coupling</strong> between
lines in method <code>names()</code>.</p>

<p>Let me first show you a better (though not the best!) design,
then I will try to explain its benefits:</p>

<pre>class Foo {
  public List&lt;String&gt; names() {
    return Foo.with(
      Foo.with(
        new LinkedList(),
        "Jeff"
      ),
      "Walter"
    );
  }
  private static List&lt;String&gt; with(
    List&lt;String&gt; list, String item) {
    list.add(item.toLowerCase());
    return list;
  }
}</pre>

<p>An ideal design for method <code>with()</code> would create a new instance of
<code>List</code>, populate it through <code>addAll(list)</code>, then <code>add(item)</code> to it, and
finally return. That would be perfectly
<a href="http://www.yegor256.com/2014/06/09/objects-should-be-immutable.html">immutable</a>,
but slow.</p>

<p>So, what is wrong with this:</p>

<pre>List&lt;String&gt; list = new LinkedList();
Foo.append(list, "Jeff");
Foo.append(list, "Walter");
return list;</pre>

<p>It looks perfectly clean, doesn't it? Instantiate a list, append two items to it, and
return it. Yes, it is clean—for now. Because we remember what <code>append()</code> is
doing. In a few months, we'll get back to this code, and it will look like this:</p>

<pre>List&lt;String&gt; list = new LinkedList();
// 10 more lines here
Foo.append(list, "Jeff");
Foo.append(list, "Walter");
// 10 more lines here
return list;</pre>

<p>Is it so clear now that <code>append()</code> is actually adding <code>"Jeff"</code> to <code>list</code>? What
will happen if I remove that line? Will it affect the result being
returned in the last line? I don't know. I need to <strong>check</strong> the body of method
<code>append()</code> to make sure.</p>

<p>Also, how about returning <code>list</code> first and calling <code>append()</code> afterwards? This
is what possible "refactoring" may do to our code:</p>

<pre>List&lt;String&gt; list = new LinkedList();
if (/* something */) {
  return list;
}
// 10 more lines here
Foo.append(list, "Walter");
Foo.append(list, "Jeff");
// 10 more lines here
return list;</pre>

<p>First of all, we return <code>list</code> too early, when it is not ready. But did anyone
tell me that these two calls to <code>append()</code> must happen before <code>return list</code>?
Second, we changed the order of <code>append()</code> calls. Again, did anyone tell me
that it's important to call them in that particular order?</p>

<p>Nobody. Nowhere. This is called <strong>temporal coupling</strong>.</p>

<p>Our lines are <strong>coupled</strong> together. They must stay in this particular order, but the
knowledge about that order is hidden. It's easy to destroy
the order, and our compiler won't be able to catch us.</p>

<p>To the contrary, this design doesn't have any "order":</p>

<pre>return Foo.with(
  Foo.with(
    new LinkedList(),
    "Jeff"
  ),
  "Walter"
);</pre>

<p>It just <strong>returns</strong> a list, which is constructed by a few calls to the <code>with()</code>
method. It is a single line instead of four.</p>

<p>As <a href="/2015/08/18/multiple-return-statements-in-oop.html">discussed before</a>,
an ideal method in OOP must have just a single statement, and this statement is
<code>return</code>.</p>

<p>The same is true about validation. For example, this code is bad:</p>

<pre>list.add("Jeff");
Foo.checkIfListStillHasSpace(list);
list.add("Walter");</pre>

<p>While this one is much better:</p>

<pre>list.add("Jeff");
Foo.withEnoughSpace(list).add("Walter");</pre>

<p>See the difference?</p>

<p>And, of course, an ideal approach would be to use
<a href="/2015/02/26/composable-decorators.html">composable decorators</a>
instead of these ugly static methods. But if it's not possible for
some reason, just don't make those static methods look like procedures.
Make sure they always return results, which become arguments to
further calls.</p>

    </article>
  </body>
</html>
