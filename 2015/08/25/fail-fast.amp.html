<!DOCTYPE html>
<html âš¡ lang="en">
  <head>
    <meta charset="utf-8">
    <title>Need Robust Software? Make It Fragile</title>
    <link rel="canonical" href="http://www.yegor256.com/2015/08/25/fail-fast.html" />
    <meta name="viewport" content="width=device-width,minimum-scale=1,initial-scale=1">
    <script type='application/ld+json'>
      {
        "@context": "http://schema.org",
        "@type": "BlogPosting",
        "mainEntityOfPage":{
          "@type": "WebPage",
          "@id": "http://www.yegor256.com/2015/08/25/fail-fast.html"
        },
        "headline": "Need Robust Software? Make It Fragile",
        "image": {
          "@type": "ImageObject",
          "url": "http://img.teamed.io/face-1400x1400.jpg",
          "height": 1400,
          "width": 1400
        },
        "datePublished": "2015-08-25",
        "dateModified": "2015-08-25",
        "author": {
          "@type": "Person",
          "name": "Yegor Bugayenko"
        },
        "publisher": {
          "@type": "Organization",
          "name": "yegor256.com",
          "logo": {
            "@type": "ImageObject",
            "url": "http://img.teamed.io/face-512x512.jpg",
            "width": 512,
            "height": 512
          }
        },
        "description": "How to create robust and failure-resistant software
&mdash; by making it fragile and fail fast, despite
intuitive desire to make it fail safe.
",
        "keywords": ["fail fast vs fail safe", "failure resilience", "fail fast", "fail safe", "robust architecture"]
      }
    </script>
    <style amp-boilerplate>body{-webkit-animation:-amp-start 8s steps(1,end) 0s 1 normal both;-moz-animation:-amp-start 8s steps(1,end) 0s 1 normal both;-ms-animation:-amp-start 8s steps(1,end) 0s 1 normal both;animation:-amp-start 8s steps(1,end) 0s 1 normal both}@-webkit-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-moz-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-ms-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-o-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}</style><noscript><style amp-boilerplate>body{-webkit-animation:none;-moz-animation:none;-ms-animation:none;animation:none}</style></noscript>
    <style amp-custom="amp-custom">
      body { padding: 2em; }
      article { width: 600px; max-width: 100%; margin-left: auto; margin-right: auto; }
    </style>
    <script async src="https://cdn.ampproject.org/v0.js"></script>
  </head>
  <body>
    <article>
      <h1>Need Robust Software? Make It Fragile</h1>
      <p>In any software project, the goal is to create something stable. We don&#39;t want it
to break in front of a user. We also don&#39;t want our website to show an
&quot;internal application error&quot; instead of a web page. We want our software
to work, not fail. That&#39;s a perfectly valid and logical desire,
but in order to achieve that, we have to make our software as fragile
as possible. This may sound counter-intuitive, but that&#39;s the way it is.
The more <strong>fragile</strong> your app is in development, the more <strong>robust</strong> it is
in production.</p>

<!--more-->

Black Cat, White Cat (1998) by Emir Kusturica

<p>By fragile, I&#39;m referring to the <a href="http://martinfowler.com/ieeeSoftware/failFast.pdf">Fail Fast</a>
philosophy, which is the opposite of
Fail Safe. I believe you know the difference, but let me remind you anyway,
by example. This is Fail Safe:</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kt">int</span> <span class="nf">size</span><span class="o">(</span><span class="n">File</span> <span class="n">file</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">if</span> <span class="o">(!</span><span class="n">file</span><span class="o">.</span><span class="na">exists</span><span class="o">())</span> <span class="o">{</span>
    <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
  <span class="o">}</span>
  <span class="k">return</span> <span class="n">file</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>
<span class="o">}</span></code></pre></figure>

<p>This method is supposed to calculate and return a file size. It first checks
whether the file exists. If it doesn&#39;t exist, the method returns zero. Indeed,
the file is absent, so there is no size. We could complain that the file is
absent, but what for? Why make noise? Let&#39;s keep it quiet and return zero.
We don&#39;t fail because we&#39;re trying to keep the app running. This is called Fail Safe.</p>

<p>To the contrary, this is how Fail Fast looks:</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kt">int</span> <span class="nf">size</span><span class="o">(</span><span class="n">File</span> <span class="n">file</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">if</span> <span class="o">(!</span><span class="n">file</span><span class="o">.</span><span class="na">exists</span><span class="o">())</span> <span class="o">{</span>
    <span class="k">throw</span> <span class="k">new</span> <span class="nf">IllegalArgumentException</span><span class="o">(</span>
      <span class="s">&quot;There is no such file; I can&#39;t get its length.&quot;</span>
    <span class="o">);</span>
  <span class="o">}</span>
  <span class="k">return</span> <span class="n">file</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>
<span class="o">}</span></code></pre></figure>

<p>We can&#39;t find a file? We don&#39;t hide this fact. We make this situation
public and visible. We scream and cry. We
<a href="/2015/12/01/rethrow-exceptions.html">throw</a> an exception. We <strong>want</strong> the
app to crash, break, and fail, because someone gave us a file that doesn&#39;t
exist. We complain and protest. This is called Fail Fast.</p>



<p>Which philosophy, if we follow it everywhere, will make our software
robust and failure-resilient? Only the second one &mdash; the Fail Fast.</p>

<p>Why? Because the quicker and easier the failure is, the faster it will
be fixed. And the fix will be simpler and also more visible. Fail Fast
is a much better approach for maintainability. The code becomes cleaner.
It is much easier to track a failure. All methods are ready to break and throw
an exception on even the tiniest problem.</p>

<p>In this example, if the method returns zero, it&#39;s not obvious
whether the file exists and its size is actually zero or if its name is wrong
and it is just not found. The Fail Safe approach <strong>conceals</strong> problems and makes
code less maintainable, and that&#39;s why it&#39;s difficult to stabilize.</p>

<p>In the beginning, during production, we will have many crashes and errors. But
all of them will be visible and easy to understand. We will fix them and
cover them with unit tests. Each fix will make our software more <strong>stable</strong>
and better covered by tests.</p>

<p>Software designed with the Fail Safe approach in mind will look more stable
at the beginning, but it will degrade quickly and inevitably turn into
an unmaintainable mess.</p>

<p>Software designed with the Fail Fast approach in mind will crash frequently
at the beginning but will improve its stability with every fix and eventually
become very stable and robust.</p>

<p>That&#39;s why fragility is the key success factor for robustness.</p>

    </article>
  </body>
</html>
