<!DOCTYPE html>
<html âš¡ lang="en">
  <head>
    <meta charset="utf-8">
    <title>Master Branch Must Be Read-Only</title>
    <link rel="canonical" href="http://www.yegor256.com/2014/07/21/read-only-master-branch.html" />
    <meta name="viewport" content="width=device-width,minimum-scale=1,initial-scale=1">
    <script type='application/ld+json'>
      {
        "@context": "http://schema.org",
        "@type": "BlogPosting",
        "mainEntityOfPage":{
          "@type": "WebPage",
          "@id": "http://www.yegor256.com/2014/07/21/read-only-master-branch.html"
        },
        "headline": "Master Branch Must Be Read-Only",
        "image": {
          "@type": "ImageObject",
          "url": "http://img.teamed.io/face-1400x1400.jpg",
          "height": 1400,
          "width": 1400
        },
        "datePublished": "2014-07-21",
        "dateModified": "2014-07-21",
        "author": {
          "@type": "Person",
          "name": "Yegor Bugayenko"
        },
        "publisher": {
          "@type": "Organization",
          "name": "yegor256.com",
          "logo": {
            "@type": "ImageObject",
            "url": "http://img.teamed.io/face-512x512.jpg",
            "width": 512,
            "height": 512
          }
        },
        "description": "Continuous integration doesn't work while programmers
are able to commit into the master branch. This article
explains why and proposes a solution.
",
        "keywords": ["broken builds", "continuous integration doesn't work", "commits to master branch", "continous delivery", "continous deployment", "continuous delivery preflight builds", "continuous integration"]
      }
    </script>
    <style amp-boilerplate>body{-webkit-animation:-amp-start 8s steps(1,end) 0s 1 normal both;-moz-animation:-amp-start 8s steps(1,end) 0s 1 normal both;-ms-animation:-amp-start 8s steps(1,end) 0s 1 normal both;animation:-amp-start 8s steps(1,end) 0s 1 normal both}@-webkit-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-moz-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-ms-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-o-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}</style><noscript><style amp-boilerplate>body{-webkit-animation:none;-moz-animation:none;-ms-animation:none;animation:none}</style></noscript>
    <style amp-custom="amp-custom">
      body { padding: 2em; }
      article { width: 600px; max-width: 100%; margin-left: auto; margin-right: auto; }
    </style>
    <script async src="https://cdn.ampproject.org/v0.js"></script>
  </head>
  <body>
    <article>
      <h1>Master Branch Must Be Read-Only</h1>
      <p>Continuous integration is easy. Download Jenkins, install,  create a job, click
the button, and get a nice email saying that your build is broken (I assume your
build is automated). Then, fix broken tests (I assume you have tests), and get a
much better looking email saying that your build is clean.</p>

<p>Then, tweet about it, claiming that your team is using
<a href="/2014/10/08/continuous-integration-is-dead.html">continuous integration</a>.</p>

<p>Then, in a few weeks, start filtering out Jenkins alerts, into their own folder,
so that they don&#39;t bother you anymore. Anyway, your team doesn&#39;t have the time
or desire to fix all unit tests every time someone breaks them.</p>

<p>After all, we all know that unit testing is not for
a team working with deadlines, right?</p>

<p>Wrong. Continuous integration can and must work.</p>

<!--more-->

<h2 id="what-is-continuous-integration">What is Continuous Integration?</h2>

<p>Nowadays, software development is done in teams.
We develop in feature branches and isolate changes while
they are in development. Then, we merge branches into <code>master</code>.
After every merge, we test the entire product, executing all
available unit and integration tests.
This is called <a href="https://en.wikipedia.org/wiki/Continuous_integration">continuous integration</a> (aka &quot;CI&quot;).</p>

<p>Sometimes, some tests fail. When this happens, we say that our
&quot;build is broken&quot;. Such a failure is a positive
side effect of quality control because it raises a red
flag immediately after an error gets into <code>master</code>.</p>

<p>It is a well-known practice, when fixing that error becomes
a top priority for its author and the entire team. The error
should be fixed right after a red flag is raised by the
<a href="/2014/10/08/continuous-integration-is-dead.html">continuous integration</a> server.</p>

<figure class='badge'><a href='http://www.amazon.com/gp/product/0321601912/ref=as_li_tl?ie=UTF8&amp;camp=1789&amp;creative=390957&amp;creativeASIN=0321601912&amp;linkCode=as2&amp;tag=yegor256com-20&amp;linkId=GKWBKGZUJGJLFMHE'></a></figure>

<p><a href="http://www.amazon.com/gp/product/0321601912/ref=as_li_tl?ie=UTF8&amp;camp=1789&amp;creative=390957&amp;creativeASIN=0321601912&amp;linkCode=as2&amp;tag=yegor256com-20&amp;linkId=GKWBKGZUJGJLFMHE">Continuous Delivery by Jez Humble et. al.</a>
explains this approach perfectly in Chapter 7, pages 169&ndash;186.</p>

<p>There are a few good tools on the market, which automate DevOps procedures.
Some of them are open source, you can download
and install them on your own servers. For example:
<a href="http://jenkins-ci.org/">Jenkins</a>,
<a href="http://www.thoughtworks.com/products/go-continuous-delivery">Go</a>, and
<a href="http://cruisecontrol.sourceforge.net/">CruiseControl</a>.
Some of them are available as a service in cloud, such as:
<a href="http://www.travis-ci.org">Travis</a>,
<a href="http://www.drone.io">Drone</a>,
<a href="http://wercker.com/">Wercker</a>, and many others.</p>

<h2 id="why-continuous-integration-doesn-39-t-work">Why Continuous Integration Doesn&#39;t Work?</h2>

<p>CI is great, but the bigger the team (and the code base), the more often builds
get broken. And, the longer it takes to fix them. I&#39;ve seen many examples where
a hard working team starts to ignore red flags, raised by Jenkins, after a few
weeks or trying to keep up.</p>

<p>The team simply becomes incapable of fixing all errors in time. Mostly because
the business has other priorities. Product owners do not understand the
importance of a &quot;clean build&quot; and technical leaders can&#39;t buy time for fixing
unit tests. Moreover, the code that broke them was already in <code>master</code> and, in
most cases, has been already deployed to production and delivered to end-users.
What&#39;s the urgency of fixing some tests if business value was already delivered?</p>

<p>In the end, most development teams don&#39;t take continuous integration alerts
seriously. Jenkins or Travis are just fancy tools for them that play no role in
the entire development and delivery pipeline. No matter what continuous
integration server says, we still deliver new features to our end-users. We&#39;ll
fix our build later. And <a href="/2014/10/08/continuous-integration-is-dead.html">it&#39;s only logical</a>.</p>

<h2 id="what-is-a-solution">What Is a Solution?</h2>

<p><a href="/pdf/2014/guard-article.pdf" class="em2"
  title="Prevent Conflicts in Distributed Agile PHP Projects"><i class="icon icon-pdf"></i></a></p>

<p>Four years ago, in 2010, I published an article in <a href="http://www.phparch.com/magazine/2010-2/august/">php|Architect</a>
called &quot;Prevent Conflicts in Distributed Agile PHP Projects&quot;. In the article,
a solution was proposed (full article in <a href="/pdf/2014/guard-article.pdf">PDF</a>)
for Subversion and PHP.</p>

<p>Since that time, I used experimentally that approach in multiple
<a href="/2015/12/22/why-dont-you-contribute-to-open-source.html">open source</a>
projects and a few commercial ones with PHP, Java, Ruby and JavaScript, Git and
Subversion. In all cases, my experience was only positive, and that&#39;s why
<a href="http://www.rultor.com">rultor.com</a> was born (later about that though).</p>

<p>So, the solution is simple &mdash; prohibit anyone from merging anything
into <code>master</code> and create a script that anyone can call. The script will
merge, test, and commit. The script will not make any exceptions.
If any branch is breaking at even one unit test, the entire branch will be rejected.</p>

<p>In other words, we should raise that red flag <strong>before</strong> the code
gets into <code>master</code>. We should put the blame for broken tests on
the shoulders of its author.</p>

<p>Say, I&#39;m developing a feature in my own branch. I finished the development and
broke a few tests, accidentally. It happens, we all make mistakes. I can&#39;t merge
my changes into <code>master</code>. Git simply rejects my <code>push</code>, because I don&#39;t have the
appropriate permissions. All I can do is call a magic script, asking it to merge
my branch. The script will try to merge, but before pushing into <code>master</code>, it
will run all tests. And if any of them break, my branch will be rejected. My
changes won&#39;t be merged. Now it&#39;s my responsibility &mdash; to fix them and call
the script again.</p>

<p>In the beginning, this approach slows down the development, because everybody
has to start writing cleaner code. At the end, though, this method pays off big
time.</p>

<h2 id="pre-flight-builds">Pre-flight Builds</h2>

<p>Some CI servers offer pre-flight builds feature, which means testing branches
before they get merged into <code>master</code>. Travis, for example, has this feature and
it is very helpful. When you make a new commit to a branch, Travis immediately
tries to build it, and reports in GitHub pull request, if there are problems.</p>

<p>Pay attention, pre-flight builds don&#39;t merge. They just check whether your
individual branch is clean. After merge, it can easily break <code>master</code>. And, of
course, this mechanism doesn&#39;t guarantee that no collaborators can commit
directly to <code>master</code>, breaking it accidentally. Pre-flight builds are a
preventive measure, but do not solve the problem entirely.</p>

<h2 id="rultor-com">Rultor.com</h2>

<p>In order to start working as explained above, all you have to do is to revoke
write permissions to <code>master</code> branch (or <code>/trunk</code>, in Subversion).</p>

<p>Unfortunately, this is <a href="http://stackoverflow.com/questions/10381672">not possible</a>
in GitHub. The only solution is to work through forks and pull requests only.
Simply remove everybody from the list of &quot;collaborators&quot; and they will
have to submit changes through pull requests.</p>

<figure class='badge'><a href='http://www.rultor.com'></a></figure>

<p>Then, start using <a href="http://www.rultor.com">Rultor.com</a>, which will help
you to test, merge and push every pull request. Basically, Rultor is
the script we were talking about above. It is available as a free cloud service.</p>

<p>ps. A short version of this article is also published at
<a href="http://devops.com/blogs/continuous-integration-doesnt-work/">devops.com</a></p>

    </article>
  </body>
</html>
