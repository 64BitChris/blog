<!DOCTYPE html>
<html amp lang="en">
  <head>

    <meta charset="utf-8">
    <title>Every Build in Its Own Docker Container</title>
    <link rel="canonical" href="http://www.yegor256.com/2014/07/29/docker-in-rultor.html">
    <meta name="viewport" content="width=device-width,minimum-scale=1,initial-scale=1">
    <script type="application/ld+json">
      {
        "@context": "http://schema.org",
        "@type": "BlogPosting",
        "mainEntityOfPage":{
          "@type": "WebPage",
          "@id": "http://www.yegor256.com/2014/07/29/docker-in-rultor.html"
        },
        "headline": "Every Build in Its Own Docker Container",
        "image": {
          "@type": "ImageObject",
          "url": "http://img.teamed.io/face-1400x1400.jpg",
          "height": 1400,
          "width": 1400
        },
        "datePublished": "2014-07-29",
        "dateModified": "2014-07-29",
        "author": {
          "@type": "Person",
          "name": "Yegor Bugayenko"
        },
        "publisher": {
          "@type": "Organization",
          "name": "yegor256.com",
          "logo": {
            "@type": "ImageObject",
            "url": "http://img.teamed.io/face-512x512.jpg",
            "width": 512,
            "height": 512
          }
        },
        "description": "Rultor.com runs every build in its own Docker container,
perfectly isolating configurations and making them cacheable and reproducible.
",
        "keywords": ["continuous integration", "docker continuous integration", "continuous delivery", "docker continuous delivery", "jenkins docker", "docker builds ci", "unit tests in docker"]
      }
    </script>
    <style amp-boilerplate>body{-webkit-animation:-amp-start 8s steps(1,end) 0s 1 normal both;-moz-animation:-amp-start 8s steps(1,end) 0s 1 normal both;-ms-animation:-amp-start 8s steps(1,end) 0s 1 normal both;animation:-amp-start 8s steps(1,end) 0s 1 normal both}@-webkit-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-moz-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-ms-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-o-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}</style>
<noscript><style amp-boilerplate>body{-webkit-animation:none;-moz-animation:none;-ms-animation:none;animation:none}</style></noscript>
    <style amp-custom="amp-custom">
      body { padding: 2em; }
      article { width: 600px; max-width: 100%; margin-left: auto; margin-right: auto; }
      .intro { color: red; font-size: .75em; }
    </style>
    <script async src="https://cdn.ampproject.org/v0.js"></script>
  </head>
  <body>
    <article>
      <p class="intro">
        This is an AMP version of the article,
        its original content can be found
        <a href="http://www.yegor256.com/2014/07/29/docker-in-rultor.html">here</a>.
      </p>
      <h1>Every Build in Its Own Docker Container</h1>
      

<p><a href="http://www.docker.io">Docker</a> is a command line tool that
can run a shell command in a virtual Linux, inside an isolated file system.
Every time we build our projects, we want them to run in their own
Docker containers. Take this Maven project for example:</p>





<p>This command will start a new Ubuntu system and execute
<code>mvn clean test</code> inside it. <a href="http://www.rultor.com">Rultor.com</a>, our
virtual assistant, does exactly that with our builds, when we
deploy, package, test and merge them.</p>



<h2 id="why-docker">Why Docker?</h2>

<p>What benefits does it give us? And why
<a href="/2014/08/29/docker-non-root.html">Docker</a>,
when there are many <a href="https://en.wikipedia.org/wiki/Operating_system-level_virtualization">other virtualization technologies</a>,
like LXC, for example?</p>

<p>Well, there are a few very important benefits:</p>

<ul>
<li><p>Image repository (hub.docker.com)</p></li>
<li><p>Versioning</p></li>
<li><p>Application-centric</p></li>
</ul>

<p>Let's discuss them in details.</p>

<h2 id="image-repository">Image Repository</h2>

<p>Docker enables image sharing through its public repository at
<a href="http://hub.docker.com">hub.docker.com</a>. This means that after
I prepare a working environment for my application, I make
an image out of it and push it to the hub.</p>

<p>Let's say, I want my Maven build to be executed in a container
with a pre-installed <code>graphviz</code> package (in order to enable <code>dot</code> command line tool).
First, I would start a plain vanilla Ubuntu container, and install <code>graphviz</code> inside it:</p>



<p>I have a container that stopped a few seconds ago. Container's
ID is <code>215d2696e8ad</code>. Now, I want to make it reusable for all
further tests in Rultor.com. I have to create an image from it:</p>



<p>I just made my new commit to a new image <code>yegor256/beta</code>.
This image can be reused right now. I can create a new container
from this image and it will have <code>graphviz</code> installed inside!</p>

<p>Now it's time to share my image at Docker hub, in order to make it available for Rultor:</p>



<p>The last step is to configure Rultor to use this image in
all builds. To do this, I will edit <a href="http://doc.rultor.com/reference.html"><code>.rultor.yml</code></a>
in the root directory of my GitHub repository:</p>



<p>That's it. From now on, Rultor will use my custom Docker image with
pre-installed <code>graphviz</code>, in every build (merge, release, deploy, etc.)</p>

<p>Moreover, if and when I want to add something else to the image,
it's easy to do. Say, I want to install Ruby into my build image.
I start a container from the image and install it (pay attention,
I'm starting a container not from <code>ubuntu</code> image, as I did before, but from <code>yegor256/beta</code>):</p>



<p>You can now see that I have two containers. The first one is the one
I am using right now; it contains Ruby. The second one is the one
I was using before and it contains <code>graphviz</code>.</p>

<p>Now I have to commit again and push:</p>



<p>Thus, this Docker hub is a very convenient feature for Rultor and similar systems.</p>

<h2 id="versioning">Versioning</h2>

<p>As you saw in the example above, every change to a Docker image has
its own version (hash) and it's possible to track changes.
It is also possible to roll back to any particular change.</p>

<p>Rultor is not using this functionality itself, but Rultor users
are able to control their build configurations with much better precision.</p>

<h2 id="application-centric">Application-Centric</h2>

<p>Docker, unlike LXC or Vagrant, for example, is application-centric.
This means that when we start a container — we start an application.
With other virtualization technologies, when you get a virtual machine —
you get a fully functional Unix environment, where you can login through
SSH and do whatever you want.</p>

<p>Docker makes things simpler. It doesn't give you SSH access to container,
but runs an application inside and shows you its output. This is
exactly what we need in Rultor. We need to run an automated build
(for example Maven or Bundler), see its output and get its exit code.
If the code is not zero, we fail the build and report to the user.</p>

<p>This is how we run Maven build:</p>



<p>As you can see, Maven starts immediately. We don't worry
about the internals of the container. We just start an application inside it.</p>

<p>Furthermore, thanks to the <code>--rm</code> option, the container gets
destroyed immediately after Maven execution is finished.</p>

<p>This is what application-centric is about.</p>

<p>Our overall impression of Docker is highly positive.</p>

<p>ps. A compact version of this article was published at
<a href="http://devops.com/blogs/build-docker-containers/">devops.com</a></p>

    </article>
  </body>
</html>
