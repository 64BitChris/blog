<!DOCTYPE html>
<html amp lang="en">
  <head>

    <meta charset="utf-8">
    <title>Fluent Java HTTP Client</title>
    <link rel="canonical" href="http://www.yegor256.com/2014/04/11/jcabi-http-intro.html">
    <meta name="viewport" content="width=device-width,minimum-scale=1,initial-scale=1">
    <script type="application/ld+json">
      {
        "@context": "http://schema.org",
        "@type": "BlogPosting",
        "mainEntityOfPage":{
          "@type": "WebPage",
          "@id": "http://www.yegor256.com/2014/04/11/jcabi-http-intro.html"
        },
        "headline": "Fluent Java HTTP Client",
        "image": {
          "@type": "ImageObject",
          "url": "http://img.teamed.io/face-1400x1400.jpg",
          "height": 1400,
          "width": 1400
        },
        "datePublished": "2014-04-11",
        "dateModified": "2014-04-11",
        "author": {
          "@type": "Person",
          "name": "Yegor Bugayenko"
        },
        "publisher": {
          "@type": "Organization",
          "name": "yegor256.com",
          "logo": {
            "@type": "ImageObject",
            "url": "http://img.teamed.io/face-512x512.jpg",
            "width": 512,
            "height": 512
          }
        },
        "description": "I created a simple fluent Java HTTP client to make things
easier with HTTP interactions; the article explains its benefits
comparing with native Java and Apache HttpClient
",
        "keywords": ["alternative to apache http client", "best java http client library", "http client java", "httpclient fluent", "httpclient java", "java http client"]
      }
    </script>
    <style amp-boilerplate>body{-webkit-animation:-amp-start 8s steps(1,end) 0s 1 normal both;-moz-animation:-amp-start 8s steps(1,end) 0s 1 normal both;-ms-animation:-amp-start 8s steps(1,end) 0s 1 normal both;animation:-amp-start 8s steps(1,end) 0s 1 normal both}@-webkit-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-moz-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-ms-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-o-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}</style>
<noscript><style amp-boilerplate>body{-webkit-animation:none;-moz-animation:none;-ms-animation:none;animation:none}</style></noscript>
    <style amp-custom="amp-custom">
      body { padding: 2em; }
      article { width: 600px; max-width: 100%; margin-left: auto; margin-right: auto; }
      .intro { color: red; font-size: .75em; }
    </style>
    <script async src="https://cdn.ampproject.org/v0.js"></script>
  </head>
  <body>
    <article>
      <p class="intro">
        This is an AMP version of the article,
        its original content can be found
        <a href="http://www.yegor256.com/2014/04/11/jcabi-http-intro.html">here</a>.
      </p>
      <h1>Fluent Java HTTP Client</h1>
      

<p>In the world of Java, there are plenty of HTTP clients from which to choose.
Nevertheless, I decided to create a new one because none of the other clients
satisfied fully all of my requirements. Maybe, I'm too demanding. Still, this is
how my <a href="http://http.jcabi.com/">jcabi-http</a> client interacts when you make an
HTTP request and expect a successful HTML page in return:</p>



<p>I designed this new client with the following requirements in mind:</p>



<h2 id="simplicity">Simplicity</h2>

<p>For me, this was the most important requirement. The client must be simple and
easy to use. In most cases, I need only to make an HTTP request and parse the
JSON response to return a value. For example, this is how I use the new client
to return a current EUR rate:</p>



<p>I assume that the above is easy to understand and maintain.</p>

<h2 id="fluent-interface">Fluent Interface</h2>

<p>The new client has to be fluent, which means that the entire server interaction
fits into one Java statement. Why is this important? I think that <a href="http://martinfowler.com/bliki/FluentInterface.html">fluent
interface</a> is the most
compact and expressive way to perform multiple imperative calls. To my
knowledge, none of the existing libraries enable this type of fluency.</p>

<h2 id="testable-and-extensible">Testable and Extensible</h2>

<p>I'm a big fan of interfaces, mostly because they make your designs both cleaner
and highly extensible at the same time. In <a href="http://http.jcabi.com/">jcabi-http</a>,
there are five interfaces extended by 20 classes.</p>

<p><a href="http://http.jcabi.com/apidocs-1.3/com/jcabi/http/Request.html"><code>Request</code></a>
is an interface, as well as
<a href="http://http.jcabi.com/apidocs-1.3/com/jcabi/http/Response.html"><code>Response</code></a>,
<a href="http://http.jcabi.com/apidocs-1.3/com/jcabi/http/RequestURI.html"><code>RequestURI</code></a>,
and
<a href="http://http.jcabi.com/apidocs-1.3/com/jcabi/http/RequestBody.html"><code>RequestBody</code></a>
exposed by it.</p>

<p>Use of interfaces makes the library highly extensible. For example, we have
<a href="http://http.jcabi.com/apidocs-1.3/com/jcabi/http/request/JdkRequest.html"><code>JdkRequest</code></a>
and
<a href="http://http.jcabi.com/apidocs-1.3/com/jcabi/http/request/ApacheRequest.html"><code>ApacheRequest</code></a>,
which make actual HTTP calls to the server using two completely
different technologies: (JDK <code>HttpURLConnection</code> and Apache HTTP Client, respectively).
In the future, it will be possible to introduce new implementations without breaking existing code.</p>

<p>Say, for instance, I want to fetch a page and then do something with it. These two calls perform the task differently, but the end results are the same:</p>



<h2 id="xml-and-json-out-of-the-box">XML and JSON Out-of-the-Box</h2>

<p>There are two common standards that I wanted the library to support right out of
the box. In most cases, the response retrieved from a server is in either XML or
<a href="/2015/11/16/json-vs-xml.html">JSON</a>
format. It has always been a hassle, and extra work, for me to parse the
output to take care of formatting issues.</p>

<p><a href="http://http.jcabi.com/">jcabi-http</a> client supports them both out of the box,
and it's possible to add more formats in the future as needed. For example, you
can fetch XML and retrieve a string value from its element:</p>



<p>Basically, the response produced by <code>fetch()</code> is decorated by <code>XmlResponse</code>. This then exposes the <code>xml()</code> method that returns an instance of the <a href="http://xml.jcabi.com/apidocs-0.7.7/com/jcabi/xml/XML.html"><code>XML</code></a> interface.</p>

<p>The same can be done with JSON through the Java JSON API
(<a href="https://jcp.org/en/jsr/detail?id=353">JSR-353</a>).</p>

<p>None of the libraries that I'm aware of or worked with offer this feature.</p>

<h2 id="immutable">Immutable</h2>

<p>The last requirement, but certainly not the least important, is that I need all interfaces of the
library to be annotated with <a href="http://aspects.jcabi.com/annotation-immutable.html"><code>@Immutable</code></a>.
This is important because I need to be able to encapsulate an instance of <code>Request</code> in other immutable classes.</p>

<p>ps. A short summary of this article was published at
<a href="http://java.dzone.com/articles/jcabi-http-fluent-java-http">JavaLobby</a></p>

    </article>
  </body>
</html>
