<!DOCTYPE html>
<html âš¡ lang="en">
  <head>
    <meta charset="utf-8">
    <title></title>
    <link rel="canonical" href="http://www.yegor256.com" />
    <meta name="viewport" content="width=device-width,minimum-scale=1,initial-scale=1">
    <style amp-boilerplate>body{-webkit-animation:-amp-start 8s steps(1,end) 0s 1 normal both;-moz-animation:-amp-start 8s steps(1,end) 0s 1 normal both;-ms-animation:-amp-start 8s steps(1,end) 0s 1 normal both;animation:-amp-start 8s steps(1,end) 0s 1 normal both}@-webkit-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-moz-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-ms-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-o-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}</style><noscript><style amp-boilerplate>body{-webkit-animation:none;-moz-animation:none;-ms-animation:none;animation:none}</style></noscript>
    <script async src="https://cdn.ampproject.org/v0.js"></script>
  </head>
  <body>
    <h1></h1>
    

<p>Say, you want to allow a Java method to work for
a maximum of five seconds and want an exception
to be thrown if the timeframe is exceeded. Here is how
you can do it with <a href="http://aspects.jcabi.com">jcabi-aspects</a>
and <a href="http://eclipse.org/aspectj/">AspectJ</a>:</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Resource</span> <span class="o">{</span>
  <span class="nd">@Timeable</span><span class="o">(</span><span class="n">limit</span> <span class="o">=</span> <span class="mi">5</span><span class="o">,</span> <span class="n">unit</span> <span class="o">=</span> <span class="n">TimeUnit</span><span class="o">.</span><span class="na">SECONDS</span><span class="o">)</span>
  <span class="kd">public</span> <span class="n">String</span> <span class="nf">load</span><span class="o">(</span><span class="n">URL</span> <span class="n">url</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">url</span><span class="o">.</span><span class="na">openConnection</span><span class="o">().</span><span class="na">getContent</span><span class="o">();</span>
  <span class="o">}</span>
<span class="o">}</span></code></pre></figure>

<!--more-->

<p>Keep in mind that you should weave your classes after
compilation, as explained <a href="http://aspects.jcabi.com/example-weaving.html">here</a>.</p>

<p>Let&#39;s discuss how this actually works, but first,
I recommend you read <a href="/2014/06/01/aop-aspectj-java-method-logging.html">this post</a>,
which explains how AOP aspects work together with Java annotations.</p>

<p>Due to <a href="http://aspects.jcabi.com/annotation-timeable.html"><code>@Timeable</code></a>
annotation and class weaving, every call to a method <code>load()</code>
is intercepted by an aspect from <a href="http://aspects.jcabi.com">jcabi-aspects</a>.
That aspect starts a new thread that monitors the execution of a method
every second, checking whether it is still running.</p>

<p>If the method runs for over five seconds, the thread
calls <a href="http://docs.oracle.com/javase/7/docs/api/java/lang/Thread.html#interrupt%28%29"><code>interrupt()</code></a>
on the method&#39;s thread.</p>

<p>Despite a very common expectation that a thread should be terminated
immediately on that call, it is not happening at all.
<a href="http://docs.oracle.com/javase/1.5.0/docs/guide/misc/threadPrimitiveDeprecation.html">This article</a>
explains the mechanism in more detail. Let&#39;s discuss it briefly:</p>

<ol>
<li><p><a href="http://docs.oracle.com/javase/7/docs/api/java/lang/Thread.html#interrupt%28%29"><code>interrupt()</code></a>
sets a marker in a thread;</p></li>
<li><p>The thread checks <a href="http://docs.oracle.com/javase/7/docs/api/java/lang/Thread.html#interrupt%28%29"><code>interrupted()</code></a>
as often as it can;</p></li>
<li><p>If the marker is set, the thread stops and throws
<a href="http://docs.oracle.com/javase/7/docs/api/java/lang/InterruptedException.html"><code>InterruptedException</code></a></p></li>
</ol>

<p>This method will <strong>not</strong> react to <code>interrupt()</code> call and will work until JVM is killed (very bad design):</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kt">void</span> <span class="nf">work</span><span class="o">()</span> <span class="o">{</span>
  <span class="k">while</span> <span class="o">(</span><span class="kc">true</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// do something</span>
  <span class="o">}</span>
<span class="o">}</span></code></pre></figure>

<p>This is how we should refactor it in order to make
sensitive to interruption requests:</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kt">void</span> <span class="nf">work</span><span class="o">()</span> <span class="o">{</span>
  <span class="k">while</span> <span class="o">(</span><span class="kc">true</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">Thread</span><span class="o">.</span><span class="na">interruped</span><span class="o">())</span> <span class="o">{</span>
      <span class="k">throw</span> <span class="k">new</span> <span class="nf">InterruptedException</span><span class="o">();</span>
    <span class="o">}</span>
    <span class="c1">// do something</span>
  <span class="o">}</span>
<span class="o">}</span></code></pre></figure>

<p>In other words, your method can only stop itself. Nothing else can do it.
The thread it is running in can&#39;t be terminated by another thread. The best
thing that the other thread can do is to send your thread a &quot;message&quot;
(through <code>interrupt()</code> method) that it&#39;s time to stop. If your thread
ignores the message, nobody can do anything.</p>

<p>Most I/O operations in JDK are designed this way. They check the
interruption status of their threads while waiting for I/O resources.</p>

<p>Thus, use <code>@Timeable</code> annotation, but keep in mind that there could
be situations when a thread can&#39;t be interrupted.</p>

  </body>
</html>
