<!DOCTYPE html>
<html âš¡ lang="en">
  <head>
    <meta charset="utf-8">
    <title>Dependency Injection Containers are Code Polluters</title>
    <!-- <link rel="canonical" href="http://www.yegor256.com/_posts/2014/oct/2014-10-03-di-containers-are-evil" /> -->
    <meta name="viewport" content="width=device-width,minimum-scale=1,initial-scale=1">
    <script type='application/ld+json'>
      {
        "@context": "http://schema.org",
        "@type": "BlogPosting",
        "mainEntityOfPage":{
          "@type": "WebPage",
          "@id": "_posts/2014/oct/2014-10-03-di-containers-are-evil.md"
        },
        "headline": "Dependency Injection Containers are Code Polluters",
        "image": {
          "@type": "ImageObject",
          "url": "http://img.teamed.io/face-1400x1400.jpg",
          "height": 1400,
          "width": 1400
        },
        "datePublished": "2014-10-03",
        "dateModified": "2014-10-03",
        "author": {
          "@type": "Person",
          "name": "Yegor Bugayenko"
        },
        "publisher": {
          "@type": "Person",
          "name": "Yegor Bugayenko"
        },
        "description": "While dependency injection is a natural object-oriented
mechanism, DI frameworks turn it into an anti-pattern.
",
        "keywords": ["dependency injection", "dependency injection is evil", "downsides of dependency injection", "dependency injection framework", "drawbacks of dependency injection", "setter injection", "constructor injection", "field injection"]
      }
    </script>
    <style amp-boilerplate>body{-webkit-animation:-amp-start 8s steps(1,end) 0s 1 normal both;-moz-animation:-amp-start 8s steps(1,end) 0s 1 normal both;-ms-animation:-amp-start 8s steps(1,end) 0s 1 normal both;animation:-amp-start 8s steps(1,end) 0s 1 normal both}@-webkit-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-moz-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-ms-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-o-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}</style><noscript><style amp-boilerplate>body{-webkit-animation:none;-moz-animation:none;-ms-animation:none;animation:none}</style></noscript>
    <script async src="https://cdn.ampproject.org/v0.js"></script>
  </head>
  <body>
    <h1>Dependency Injection Containers are Code Polluters</h1>
    <p>While <a href="http://martinfowler.com/articles/injection.html">dependency injection</a> (aka, &quot;DI&quot;)
is a natural technique of composing objects in OOP
(known long before the term was <a href="http://www.martinfowler.com/articles/injection.html">introduced by Martin Fowler</a>),
<a href="http://www.spring.io">Spring IoC</a>,
<a href="https://code.google.com/p/google-guice/">Google Guice</a>,
<a href="http://docs.oracle.com/javaee/6/tutorial/doc/giwhl.html">Java EE6 CDI</a>,
<a href="http://square.github.io/dagger/">Dagger</a> and other
<a href="https://en.wikipedia.org/wiki/Dependency_injection">DI frameworks</a>
turn it into an <strong>anti-pattern</strong>.</p>

<!--more-->

<p>I&#39;m not going to discuss obvious arguments against
&quot;setter injections&quot;
(like in <a href="http://www.springbyexample.org/examples/intro-to-ioc-basic-setter-injection.html">Spring IoC</a>)
and
&quot;field injections&quot;
(like in <a href="http://picocontainer.codehaus.org/annotated-field-injection.html">PicoContainer</a>).
These mechanisms simply violate basic principles
of object-oriented programming and encourage us to create
incomplete, mutable objects, that get stuffed with data during the course
of application execution. Remember: ideal objects
<a href="/2014/06/09/objects-should-be-immutable.html">must be immutable</a>
and <a href="/2014/09/16/getters-and-setters-are-evil.html">may not contain setters</a>.</p>

<p>Instead, let&#39;s talk about &quot;constructor injection&quot;
(like in <a href="https://github.com/google/guice/wiki/Injections#constructor-injection">Google Guice</a>)
and its use with dependency injection <strong>containers</strong>.
I&#39;ll try to show why I consider these containers a redundancy, at least.</p>

<h2 id="what-is-dependency-injection">What is Dependency Injection?</h2>

<p>This is what dependency injection is (not really different
from a plain old object <a href="/2015/02/26/composable-decorators.html">composition</a>):</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Budget</span> <span class="o">{</span>
  <span class="kd">private</span> <span class="kd">final</span> <span class="n">DB</span> <span class="n">db</span><span class="o">;</span>
  <span class="kd">public</span> <span class="nf">Budget</span><span class="o">(</span><span class="n">DB</span> <span class="n">data</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">this</span><span class="o">.</span><span class="na">db</span> <span class="o">=</span> <span class="n">data</span><span class="o">;</span>
  <span class="o">}</span>
  <span class="kd">public</span> <span class="kt">long</span> <span class="nf">total</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="k">this</span><span class="o">.</span><span class="na">db</span><span class="o">.</span><span class="na">cell</span><span class="o">(</span>
      <span class="s">&quot;SELECT SUM(cost) FROM ledger&quot;</span>
    <span class="o">);</span>
  <span class="o">}</span>
<span class="o">}</span></code></pre></figure>

<p>The object <code>data</code> is called a &quot;dependency&quot;.</p>

<p>A <code>Budget</code> doesn&#39;t know what kind of database it is working with. All it
needs from the database is its ability to fetch a cell, using an
arbitrary SQL query, via method <code>cell()</code>. We can instantiate a <code>Budget</code> with a PostgreSQL
implementation of the <code>DB</code> interface, for example:</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">App</span> <span class="o">{</span>
  <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">...</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">Budget</span> <span class="n">budget</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">Budget</span><span class="o">(</span>
      <span class="k">new</span> <span class="nf">Postgres</span><span class="o">(</span><span class="s">&quot;jdbc:postgresql:5740/main&quot;</span><span class="o">)</span>
    <span class="o">);</span>
    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;Total is: &quot;</span> <span class="o">+</span> <span class="n">budget</span><span class="o">.</span><span class="na">total</span><span class="o">());</span>
  <span class="o">}</span>
<span class="o">}</span></code></pre></figure>

<p>In other words, we&#39;re &quot;injecting&quot; a dependency into a new object <code>budget</code>.</p>

<p>An alternative to this &quot;dependency injection&quot; approach would be
to let <code>Budget</code> decide what database it wants to work with:</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Budget</span> <span class="o">{</span>
  <span class="kd">private</span> <span class="kd">final</span> <span class="n">DB</span> <span class="n">db</span> <span class="o">=</span>
    <span class="k">new</span> <span class="nf">Postgres</span><span class="o">(</span><span class="s">&quot;jdbc:postgresql:5740/main&quot;</span><span class="o">);</span>
  <span class="c1">// class methods</span>
<span class="o">}</span></code></pre></figure>

<p>This is very dirty and leads to 1) code duplication, 2) inability
to reuse, and 3) inability to test, etc. No need to discuss
why. It&#39;s <a href="http://programmers.stackexchange.com/questions/19203">obvious</a>.</p>

<p>Thus, dependency injection via a constructor is an amazing technique.
Well, not even a technique, really. More like a feature of Java and all other object-oriented
languages. It&#39;s expected that almost any object will want to
<a href="/2014/12/15/how-much-your-objects-encapsulate.html">encapsulate</a>
some knowledge (aka, a &quot;state&quot;). That&#39;s what
<a href="/2015/05/07/ctors-must-be-code-free.html">constructors</a> are for.</p>

<h2 id="what-is-a-di-container">What is a DI Container?</h2>

<p>So far so good, but here comes the dark side &mdash; a dependency
injection container. Here is how it works (let&#39;s use
<a href="https://github.com/google/guice">Google Guice</a>
as an example):</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kn">import</span> <span class="nn">javax.inject.Inject</span><span class="o">;</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Budget</span> <span class="o">{</span>
  <span class="kd">private</span> <span class="kd">final</span> <span class="n">DB</span> <span class="n">db</span><span class="o">;</span>
  <span class="nd">@Inject</span>
  <span class="kd">public</span> <span class="nf">Budget</span><span class="o">(</span><span class="n">DB</span> <span class="n">data</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">this</span><span class="o">.</span><span class="na">db</span> <span class="o">=</span> <span class="n">data</span><span class="o">;</span>
  <span class="o">}</span>
  <span class="c1">// same methods as above</span>
<span class="o">}</span></code></pre></figure>

<p>Pay attention: the constructor is annotated with
<a href="http://docs.oracle.com/javaee/6/api/javax/inject/Inject.html"><code>@Inject</code></a>.</p>

<p>Then, we&#39;re supposed to configure a container
somewhere, when the application starts:</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">Injector</span> <span class="n">injector</span> <span class="o">=</span> <span class="n">Guice</span><span class="o">.</span><span class="na">createInjector</span><span class="o">(</span>
  <span class="k">new</span> <span class="nf">AbstractModule</span><span class="o">()</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">configure</span><span class="o">()</span> <span class="o">{</span>
      <span class="k">this</span><span class="o">.</span><span class="na">bind</span><span class="o">(</span><span class="n">DB</span><span class="o">.</span><span class="na">class</span><span class="o">).</span><span class="na">toInstance</span><span class="o">(</span>
        <span class="k">new</span> <span class="nf">Postgres</span><span class="o">(</span><span class="s">&quot;jdbc:postgresql:5740/main&quot;</span><span class="o">)</span>
      <span class="o">);</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">);</span></code></pre></figure>

<p>Some frameworks even allow us to configure the injector in an XML file.</p>

<p>From now on, we are not allowed to instantiate <code>Budget</code> through the <code>new</code> operator,
like we did before. Instead, we should use the injector we just created:</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">App</span> <span class="o">{</span>
  <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">...</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">Injection</span> <span class="n">injector</span> <span class="o">=</span> <span class="c1">// as we just did in the previous snippet</span>
    <span class="n">Budget</span> <span class="n">budget</span> <span class="o">=</span> <span class="n">injector</span><span class="o">.</span><span class="na">getInstance</span><span class="o">(</span><span class="n">Budget</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;Total is: &quot;</span> <span class="o">+</span> <span class="n">budget</span><span class="o">.</span><span class="na">total</span><span class="o">());</span>
  <span class="o">}</span>
<span class="o">}</span></code></pre></figure>

<p>The injection automatically finds out that in order to instantiate
a <code>Budget</code> it has to provide an argument for its constructor. It will
use an instance of class <code>Postgres</code>, which we instantiated in the injector.</p>

<p>This is the right and recommended way to use Guice. There are
a few even darker patterns, though, which are possible but not recommended. For example,
you can make your injector a
<a href="/2016/06/27/singletons-must-die.html">singleton</a> and use it right inside the <code>Budget</code> class.
These mechanisms are considered wrong even by DI container makers, however, so let&#39;s ignore
them and focus on the recommended scenario.</p>

<h2 id="what-is-this-for">What Is This For?</h2>

<p>Let me reiterate and summarize the scenarios of <strong>incorrect usage</strong> of dependency
injection containers:</p>

<ul>
<li><p>Field injection</p></li>
<li><p>Setter injection</p></li>
<li><p>Passing injector as a dependency</p></li>
<li><p>Making injector a global <a href="/2016/06/27/singletons-must-die.html">singleton</a></p></li>
</ul>

<p>If we put all of them aside, all we have left is the constructor
injection explained above. And how does that help us? Why do we need it?
Why can&#39;t we use plain old <code>new</code> in the main class of the application?</p>

<p>The container we created simply adds more lines to the code base,
or even more files, if we use XML. And it doesn&#39;t add anything, except
an additional <strong>complexity</strong>. We should always remember this
if we have the question: &quot;What database is used as an argument of a Budget?&quot;</p>

<h2 id="the-right-way">The Right Way</h2>

<p>Now, let me show you a real life example of using <code>new</code> to construct
an application. This is how we create a &quot;thinking engine&quot; in
<a href="http://www.rultor.com">rultor.com</a> (full class is in
<a href="https://github.com/yegor256/rultor/blob/1.34/src/main/java/com/rultor/agents/Agents.java"><code>Agents.java</code></a>):</p>

<script src="https://gist.github.com/c76c06baee1f74e3100e.js?file=Agents.java"> </script>

<p>Impressive? This is a true
<a href="/2015/02/26/composable-decorators.html">object composition</a>.
I believe this is how a proper object-oriented application
should be instantiated.</p>

<p>And DI containers? In my opinion, they just add unnecessary noise.</p>

  </body>
</html>
