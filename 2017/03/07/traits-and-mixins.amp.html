<!DOCTYPE html>
<html amp lang="en">
  <head>

    <meta charset="utf-8">
    <title>Traits and Mixins Are Not OOP</title>
    <link rel="canonical" href="http://www.yegor256.com/2017/03/07/traits-and-mixins.html">
    <meta name="viewport" content="width=device-width,minimum-scale=1,initial-scale=1">
    <script type="application/ld+json">
      {
        "@context": "http://schema.org",
        "@type": "BlogPosting",
        "mainEntityOfPage":{
          "@type": "WebPage",
          "@id": "http://www.yegor256.com/2017/03/07/traits-and-mixins.html"
        },
        "headline": "Traits and Mixins Are Not OOP",
        "image": {
          "@type": "ImageObject",
          "url": "https://cf.jare.io/?u=http://www.yegor256.com/images/2014/04/fear-and-loathing-adrenochrome.png",
          "height": 816,
          "width": 1920
        },
        "datePublished": "2017-03-07",
        "dateModified": "2017-03-07",
        "author": {
          "@type": "Person",
          "name": "Yegor Bugayenko"
        },
        "publisher": {
          "@type": "Organization",
          "name": "yegor256.com",
          "logo": {
            "@type": "ImageObject",
            "url": "http://www.yegor256.com/images/face-512x512.jpg",
            "width": 512,
            "height": 512
          }
        },
        "description": "Mixins and traits are becoming popular in OOP, but do
they really have anything to do with proper object-oriented
thinking and design?
",
        "keywords": ["traits", "oop traits", "mixin oop", "OOP", "trait in programming"]
      }
    </script>
    <style amp-boilerplate>body{-webkit-animation:-amp-start 8s steps(1,end) 0s 1 normal both;-moz-animation:-amp-start 8s steps(1,end) 0s 1 normal both;-ms-animation:-amp-start 8s steps(1,end) 0s 1 normal both;animation:-amp-start 8s steps(1,end) 0s 1 normal both}@-webkit-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-moz-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-ms-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-o-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}</style>
<noscript><style amp-boilerplate>body{-webkit-animation:none;-moz-animation:none;-ms-animation:none;animation:none}</style></noscript>
    <style amp-custom="amp-custom">
      body { padding: .5em; font-size: 1.2em; }
      article { width: 600px; max-width: 100%; margin-left: auto; margin-right: auto; }
      .intro { color: red; font-size: .75em; }
      .photo { border-radius: 50%; }
      pre { overflow-x:scroll; }
    </style>
    <script async src="https://cdn.ampproject.org/v0.js"></script>
  </head>
  <body>
    <article>
      <p class="intro">
        This is a mobile version, full one is
        <a href="http://www.yegor256.com/2017/03/07/traits-and-mixins.html">here</a>.
      </p>
      <p>
        <amp-img src="/images/yegor-bugayenko-192x192.png" width="80" height="80" alt="Yegor Bugayenko" class="photo"></amp-img>
      </p>
      <p>Yegor Bugayenko<br>7 March 2017</p>
      <h1>Traits and Mixins Are Not OOP</h1>
      <p>Let me say right off the bat that the features we will discuss here are
pure <em>poison</em> brought to object-oriented programming by those who desperately
needed a lobotomy, just like David West suggested in his
<a href="http://amzn.to/2ass77O">Object Thinking</a> book.
These features have different names, but the most common ones are
<a href="https://en.wikipedia.org/wiki/Trait_%28computer_programming%29">traits</a> and
<a href="https://en.wikipedia.org/wiki/Mixin">mixins</a>. I seriously can't understand
how we can still call programming object-oriented when it has
<a href="http://stackoverflow.com/questions/925609/mixins-vs-traits">these features</a>.</p>



<amp-img src="https://cf.jare.io/?u=http://www.yegor256.com/images/2014/04/fear-and-loathing-adrenochrome.png" alt="Fear and Loathing in Las Vegas (1998) by Terry Gilliam" height="816" width="1920" layout="responsive"></amp-img>

<p>First, here's how they work in a nutshell. Let's use
<a href="http://phrogz.net/programmingruby/tut_modules.html">Ruby modules</a>
as a sample implementation. Say that we have a class <code>Book</code>:</p>

<pre>class Book
  def initialize(title)
    @title = title
  end
end</pre>

<p>Now, we want class <code>Book</code> to use a static method (a procedure) that
does something useful. We may either define it in a
<a href="/2014/05/05/oop-alternative-to-utility-classes.html">utility class</a>
and let <code>Book</code> call it:</p>

<pre>class TextUtils
  def self.caps(text)
    text.split.map(&amp;:capitalize).join(' ')
  end
end
class Book
  def print
    puts "My title is #{TextUtils.caps(@title)}"
  end
end</pre>

<p>Or we may make it even more "convenient" and <code>extend</code> our module
in order to access its methods directly:</p>

<pre>module TextModule
  def caps(text)
    text.split.map(&amp;:capitalize).join(' ')
  end
end
class Book
  extend TextModule
  def print
    puts "My title is #{caps(@title)}"
  end
end</pre>

<p>It seems nice—if you don't understand the
<a href="/2014/05/05/oop-alternative-to-utility-classes.html">difference</a>
between
<a href="/2016/08/15/what-is-wrong-object-oriented-programming.html">object-oriented programming</a>
and static methods. Moreover, if we forget
<a href="/2014/11/20/seven-virtues-of-good-object.html">OOP purity</a>
for a minute, this approach actually looks less readable to me, even though it has
fewer characters; it's difficult to understand where the method
<code>caps()</code> is coming from when it's called just like <code>#{caps(@title)}</code> instead
of <code>#{TextUtils.caps(@title)}</code>. Don't you think?</p>

<p>Mixins start to play their role better when we <code>include</code> them. We can
combine them to construct the behavior of the class we're looking for. Let's
create two mixins. The first one will be called <code>PlainMixin</code> and will print the title
of the book the way it is, and the second one will be called <code>CapsMixin</code> and will
capitalize what's already printed:</p>

<pre>module CapsMixin
  def to_s
    super.to_s.split.map(&amp;:capitalize).join(' ')
  end
end
module PlainMixin
  def to_s
    @title
  end
end
class Book
  def initialize(title)
    @title = title
  end
  include CapsMixin, PlainMixin
  def print
    puts "My title is #{self}"
  end
end</pre>

<p>Calling <code>Book</code> without the included mixin will print its title the way
it is. Once we add the <code>include</code> statement, the behavior of <code>to_s</code> is
overridden and method <code>print</code> produces a different result. We can
combine mixins to produce the required functionality. For example,
we can add one more, which will
<a href="http://stackoverflow.com/a/25136035/187141">abbreviate</a> the title to 16 characters:</p>

<pre>module AbbrMixin
  def to_s
    super.to_s.gsub(/^(.{16,}?).*$/m,'\1...')
  end
end
class Book
  def initialize(title)
    @title = title
  end
  include AbbrMixin, CapsMixin, PlainMixin
  def print
    puts "My title is #{self}"
  end
end</pre>

<p>I'm sure you already understand that they both have access to
the private attribute <code>@title</code> of class <code>Book</code>. They actually have
full access to <em>everything</em> in the class. They litterally are
"pieces of code" that we <em>inject</em> into the class to make it more
powerful and complex. What's wrong with this approach?</p>

<p>It's the same issue as with
<a href="/2016/04/12/java-annotations-are-evil.html">annotations</a>,
<a href="/2016/07/06/data-transfer-object.html">DTOs</a>,
<a href="/2014/09/16/getters-and-setters-are-evil.html">getters</a>,
and <a href="/2014/05/05/oop-alternative-to-utility-classes.html">utility classes</a>—they
tear objects apart and place pieces of functionality in places
where objects don't see them.</p>

<p>In the case of mixins, the functionality is
in the Ruby <code>modules</code>, which make assumptions about the internal structure
of <code>Book</code> and further assume that the programmer will still understand what's in <code>Book</code> after
the internal structure changes. Such assumptions completely violate
the very idea of
<a href="/2016/11/21/naked-data.html">encapsulation</a>.</p>

<p>Such a tight coupling between mixins and object private structure
leads to nothing by unmaintainable and difficult to understand code.</p>

<p>The very obvious alternatives to mixins are
<a href="/2015/02/26/composable-decorators.html">composable decorators</a>.
Take a look at the example given in the
<a href="/2015/02/26/composable-decorators.html">article</a>:</p>

<pre>Text text = new AllCapsText(
  new TrimmedText(
    new PrintableText(
      new TextInFile(new File("/tmp/a.txt"))
    )
  )
);</pre>

<p>Doesn't it look very similar to what we were doing above with Ruby mixins?</p>

<p>However, unlike mixins, decorators leave objects small and cohesive, layering
extra functionality on top of them. Mixins do
the opposite—they make objects more complex and, thanks to that, less
readable and maintainable.</p>

<p>I honestly believe they are just poison. Whoever invented them
was a long ways from understanding the philosophy of object-oriented design.</p>

    </article>
  </body>
</html>
